var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"corgy","text":"<p>Corgy is a Python library that allows you to create feature rich data classes using intuitive type annotations.</p> <pre><code>&gt;&gt;&gt; from typing import List\n&gt;&gt;&gt; from typing_extensions import Literal\n&gt;&gt;&gt; from corgy import Corgy\n&gt;&gt;&gt; from corgy.types import KeyValuePairs\n\n&gt;&gt;&gt; class G(Corgy):\n...     x: int\n...     y: Literal[\"y1\", \"y2\", \"y3\"]\n\n&gt;&gt;&gt; class C(Corgy):\n...     x: List[float] = [1.0, 2.0]\n...     y: KeyValuePairs[str, int]\n...     g: G\n</code></pre>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Type checking: <code>Corgy</code> instances are type-checked, and support a   number of type modifiers.</li> </ul> <pre><code>&gt;&gt;&gt; from typing import Tuple\n\n&gt;&gt;&gt; class C(Corgy):\n...     x: int\n...     y: Tuple[int, int]\n\n&gt;&gt;&gt; C(x=\"1\")\nTraceback (most recent call last):\n...\nValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n\n&gt;&gt;&gt; C(y=(1, 2, 3))\nTraceback (most recent call last):\n...\nValueError: error setting `y`: invalid value for type 'typing.Tuple[int, int]': (1, 2, 3): expected exactly '2' elements\n</code></pre> <ul> <li>Dictionary interface: <code>Corgy</code> instances can be converted to/from   dictionaries.</li> </ul> <pre><code>&gt;&gt;&gt; class G(Corgy):\n...     x: int\n\n&gt;&gt;&gt; class C(Corgy):\n...     x: int\n...     g: G\n\n&gt;&gt;&gt; g = G.from_dict({\"x\": 1})\n&gt;&gt;&gt; g\nG(x=1)\n\n&gt;&gt;&gt; c = C(x=2, g=g)\n&gt;&gt;&gt; c.as_dict()\n{'x': 2, 'g': {'x': 1}}\n</code></pre> <ul> <li>Command-line parsing: <code>Corgy</code> class attributes can be added to an   <code>ArgumentParser</code> instance, and parsed from the command-line. Help   messages can be added to attributes with <code>Annotated</code>, and will be   passed to the command line parser.</li> </ul> <pre><code>&gt;&gt;&gt; from argparse import ArgumentParser\n&gt;&gt;&gt; from typing import Optional\n&gt;&gt;&gt; from typing_extensions import Annotated\n\n&gt;&gt;&gt; class ArgGroup(Corgy):\n...     arg1: Annotated[Optional[int], \"optional number\"]\n...     arg2: Annotated[bool, \"a boolean\"]\n\n&gt;&gt;&gt; class MyArgs(Corgy):\n...     arg1: Annotated[int, \"a number\"] = 1\n...     arg2: Annotated[Tuple[float, ...], \"at least one float\"]\n...     grp1: Annotated[ArgGroup, \"group 1\"]\n\n&gt;&gt;&gt; parser = ArgumentParser(usage=\"\")\n&gt;&gt;&gt; MyArgs.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()  # doctest: +SKIP\nusage:\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --arg1 ARG1           a number\n  --arg2 ARG2 [ARG2 ...]\n                        at least one float\n\ngrp1:\n  group 1\n\n  --grp1:arg1 [GRP1:ARG1]\n                        optional number\n  --grp1:arg2, --no-grp1:arg2\n                        a boolean\n</code></pre> <ul> <li>Enhanced argparse formatting: The <code>corgy</code> package provides   <code>CorgyHelpFormatter</code>, a formatter class for <code>argparse</code>, with support   for colorized output. It can also be used independent of <code>Corgy</code>   classes.</li> </ul> <pre><code>&gt;&gt;&gt; from corgy import CorgyHelpFormatter\n\n&gt;&gt;&gt; # `ArgGroup` and `MyArgs` as defined above\n&gt;&gt;&gt; parser = ArgumentParser(usage=\"\", formatter_class=CorgyHelpFormatter)\n&gt;&gt;&gt; MyArgs.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()  # doctest: +SKIP\n</code></pre> <ul> <li>Convenience types: <code>corgy.types</code> provides a number of types for   converting strings into objects like paths, dictionaries, classes,   etc. These can be used standalone, but are especially useful for   parsing from command line arguments. Refer to the docs for details on   all available types. A small example is shown below.</li> </ul> <pre><code>&gt;&gt;&gt; T = KeyValuePairs[str, int]\n&gt;&gt;&gt; m = T(\"x=1,y=2\")\n&gt;&gt;&gt; print(m)\n{'x': 1, 'y': 2}\n</code></pre>"},{"location":"index.html#install","title":"Install","text":"<p><code>corgy</code> is available on PyPI, and can be installed with pip:</p> <pre><code>pip install corgy\n</code></pre> <p>Support for colorized output requires the <code>crayons</code> package, also available on PyPI. You can pull it as a dependency for <code>corgy</code> by installing with the <code>colors</code> extra:</p> <pre><code>pip install corgy[colors]\n</code></pre> <p>Parsing <code>Corgy</code> objects from <code>toml</code> files requires the <code>tomli</code> package on Python versions below 3.11. This can be installed automatically with the <code>toml</code> extra:</p> <pre><code>pip install corgy[toml]\n</code></pre>"},{"location":"usage/corgy.html","title":"corgy","text":""},{"location":"usage/corgy.html#corgy.Corgy","title":"corgy.Corgy","text":"<p>Base class for collections of attributes.</p> <p>To use, subclass <code>Corgy</code>, and declare attributes using type annotations::</p> <pre><code>&gt;&gt;&gt; from corgy import Corgy\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: float\n</code></pre> <p>At runtime, class <code>A</code> will have <code>x</code>, and <code>y</code> as properties, so that the class can be used similar to Python dataclasses::</p> <pre><code>&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = 1\n&gt;&gt;&gt; a.x\n1\n\n&gt;&gt;&gt; a.y\nTraceback (most recent call last):\n   ...\nAttributeError: no value available for attribute `y`\n\n&gt;&gt;&gt; a.y = a.x + 1.1\n&gt;&gt;&gt; a.y\n2.1\n\n&gt;&gt;&gt; del a.x  # unset x\n&gt;&gt;&gt; a.x\nTraceback (most recent call last):\n   ...\nAttributeError: no value available for attribute `x`\n</code></pre> <p>Note that the class's <code>__init__</code> method only accepts keyword arguments, and ignores arguments without a corresponding attribute. The following are all valid::</p> <pre><code>&gt;&gt;&gt; A(x=1, y=2.1)\nA(x=1, y=2.1)\n\n&gt;&gt;&gt; A(x=1, z=3)  # y is not set, and z is ignored\nA(x=1)\n\n&gt;&gt;&gt; A(**{\"x\": 1, \"y\": 2.1, \"z\": 3})\nA(x=1, y=2.1)\n</code></pre> <p>Attribute values are type-checked, and <code>ValueError</code> is raised on type mismatch::</p> <pre><code>&gt;&gt;&gt; a = A(x=\"1\")\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = \"1\"\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: int = \"1\"\nTraceback (most recent call last):\n    ...\nValueError: default value type mismatch for 'x'\n</code></pre> <p>Any type which supports type checking with <code>isinstance</code> can be used as an attribute type (along with some special type annotations that are discussed below). This includes other corgy classes::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: float\n\n&gt;&gt;&gt; class B(Corgy):\n...     x: int\n...     a: A\n\n&gt;&gt;&gt; b = B(x=1)\n&gt;&gt;&gt; b.a = A()\n&gt;&gt;&gt; b.a.x = 10\n&gt;&gt;&gt; b\nB(x=1, a=A(x=10))\n</code></pre> <p><code>Corgy</code> classes have their <code>__slots__</code> set to the annotated attributes. So, if you want to use additional attributes not tracked by <code>Corgy</code>, define them (and only them) in <code>__slots__</code>::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     __slots__ = (\"x\",)\n...     y: int\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.y = 1  # `Corgy` attribute\n&gt;&gt;&gt; a.x = 2  # custom attribute\n&gt;&gt;&gt; a\nA(y=1)\n</code></pre> <p>To allow arbitrary instance attributes, add <code>__dict__</code> to <code>__slots__</code>. Names added through custom <code>__slots__</code> are not processed by <code>Corgy</code>. Alternatively, to disable setting <code>__slots__</code> completely, set <code>corgy_make_slots</code> to <code>False</code> in the class definition::</p> <pre><code>&gt;&gt;&gt; class A(Corgy, corgy_make_slots=False):\n...     y: int\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.y = 1  # `Corgy` attribute\n&gt;&gt;&gt; a.x = 2  # custom attribute\n&gt;&gt;&gt; a\nA(y=1)\n</code></pre> <p>Names marked with the <code>ClassVar</code> type will be added as class variables, and will not be available as <code>Corgy</code> attributes::</p> <pre><code>&gt;&gt;&gt; from typing import ClassVar\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: ClassVar[int] = 3\n\n&gt;&gt;&gt; A.x\n3\n&gt;&gt;&gt; A.x = 4\n&gt;&gt;&gt; A.x\n4\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x\n4\n&gt;&gt;&gt; a.x = 5\nTraceback (most recent call last):\n    ...\nAttributeError: 'A' object attribute 'x' is read-only\n</code></pre> <p>Also note that class variables need to be assigned to a value during definition, and this value will not be type checked by <code>Corgy</code>.</p> <p>Inheritance works as expected, whether base classes are themselves <code>Corgy</code> classes or not, with sub-classes inheriting the attributes of the base class, and overriding any redefined attributes::</p> <pre><code>&gt;&gt;&gt; class A:\n...     x: int\n\n&gt;&gt;&gt; class B(Corgy, A):\n...     y: float = 1.0\n...     z: str\n\n&gt;&gt;&gt; class C(B):\n...     y: float = 2.0\n...     z: str\n...     w: float\n\n&gt;&gt;&gt; c = C()\n&gt;&gt;&gt; print(c)\nC(x=&lt;unset&gt;, y=2.0, z=&lt;unset&gt;, w=&lt;unset&gt;)\n</code></pre> <p>Tracking of base class attributes can be disabled by setting <code>corgy_track_bases</code> to <code>False</code> in the class definition. Properties will still be inherited following standard inheritance rules, but <code>Corgy</code> will ignore them::</p> <pre><code>&gt;&gt;&gt; class A:\n...     x: int\n\n&gt;&gt;&gt; class B(Corgy, A, corgy_track_bases=False):\n...     y: float = 1.0\n...     z: str\n\n&gt;&gt;&gt; b = B()\n&gt;&gt;&gt; print(b)\nB(y=1.0, z=&lt;unset&gt;)\n</code></pre> <p><code>Corgy</code> instances can be frozen (preventing any further changes) using the <code>freeze</code> method. This method can be called automatically after <code>__init__</code> by by setting <code>corgy_freeze_after_init</code> to <code>True</code> in the class definition::</p> <pre><code>&gt;&gt;&gt; class A(Corgy, corgy_freeze_after_init=True):\n...    x: int\n\n&gt;&gt;&gt; a = A(x=1)\n&gt;&gt;&gt; a.x = 2\nTraceback (most recent call last):\n    ...\nTypeError: cannot set `x`: object is frozen\n</code></pre> <p><code>Corgy</code> recognizes a number of special annotations, which are used to control how attribute values are processed.</p> Note <p>If any of the following annotations are unavailable in the Python version being used, you can import them from <code>typing_extensions</code> (which is available on PyPI).</p> <p>Annotations <code>typing.Annotated</code> can be used to add additional metadata to attributes, akin to doc strings. It is primarily used to control how attributes are added to <code>ArgumentParser</code> instances. <code>typing.Annotated</code> is stripped on class creation, leaving only the base type::</p> <pre><code>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; if sys.version_info &gt;= (3, 9):\n...     from typing import Annotated, Literal\n... else:\n...     from typing_extensions import Annotated, Literal\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Annotated[int, \"this is x\"]\n\n&gt;&gt;&gt; A.attrs()\n{'x': &lt;class 'int'&gt;}\n</code></pre> <p><code>Annotated</code> should always be the outermost type annotation for an attribute. Refer to the docs for <code>Corgy.add_args_to_parser</code> for details on usage.</p> <p>Required/NotRequired By default, <code>Corgy</code> attributes are not required, and can be unset. This can be changed by setting <code>corgy_required_by_default</code> to <code>True</code> in the class definition::</p> <pre><code>&gt;&gt;&gt; class A(Corgy, corgy_required_by_default=True):\n...     x: int\n\n&gt;&gt;&gt; A()\nTraceback (most recent call last):\n    ...\nValueError: missing required attribute: `x`\n&gt;&gt;&gt; a = A(x=1)\n&gt;&gt;&gt; del a.x\nTraceback (most recent call last):\n    ...\nTypeError: attribute `x` cannot be unset\n</code></pre> <p>Attributes can also explicitly be marked as required/not-required using <code>corgy.Required</code> and <code>corgy.NotRequired</code> annotations::</p> <pre><code>&gt;&gt;&gt; from corgy import Required, NotRequired\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Required[int]\n...     y: NotRequired[int]\n...     z: int  # not required by default\n\n&gt;&gt;&gt; a = A(x=1)\n&gt;&gt;&gt; print(a)\nA(x=1, y=&lt;unset&gt;, z=&lt;unset&gt;)\n\n&gt;&gt;&gt; class B(Corgy, corgy_required_by_default=True):\n...     x: Required[int]\n...     y: NotRequired[int]\n...     z: int\n\n&gt;&gt;&gt; b = B(x=1, z=2)\n&gt;&gt;&gt; print(b)\nB(x=1, y=&lt;unset&gt;, z=2)\n</code></pre> <p>Optional Annotating an attribute with <code>typing.Optional</code> allows it to be <code>None</code>::</p> <pre><code>&gt;&gt;&gt; from typing import Optional\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Optional[int]\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = None\n</code></pre> <p>In Python &gt;= 3.10, instead of using <code>typing.Annotated</code>, <code>| None</code> can be used, i.e., <code>x: int | None</code> for example.</p> <p>Note that <code>Optional</code> is not the same as <code>NotRequired</code>. <code>Optional</code> allows an attribute to be <code>None</code>, while <code>NotRequired</code> allows an attribute to be unset. A <code>Required</code> <code>Optional</code> attribute will need a value (which can be <code>None</code>)::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Required[Optional[int]]\n\n&gt;&gt;&gt; A()\nTraceback (most recent call last):\n    ...\nValueError: missing required attribute: `x`\n&gt;&gt;&gt; a = A(x=None)\n&gt;&gt;&gt; print(a)\nA(x=None)\n</code></pre> <p>Collections Several collection types can be used to annotate attributes, which will restrict the type of accepted values. Values in the collection will be checked to ensure that they match the annotated collection types. The following collection types are supported:</p> <ol> <li><code>collections.abc.Sequence</code> (<code>typing.Sequence</code> on Python &lt; 3.9)</li> <li><code>tuple</code> (<code>typing.Tuple</code> on Python &lt; 3.9)</li> <li><code>list</code> (<code>typing.List</code> on Python &lt; 3.9)</li> <li><code>set</code> (<code>typing.Set</code> on Python &lt; 3.9)</li> </ol> <p>There are a few different ways to use these types, each resulting in different validation conditions. The simplest case is a plain (possibly empty) collection of a single type::</p> <pre><code>&gt;&gt;&gt; from typing import List, Sequence, Set, Tuple\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Sequence[int]\n...     y: Tuple[str]\n...     z: Set[float]\n...     w: List[int]\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = [1, 2]\n&gt;&gt;&gt; a.y = (\"1\", \"2\")\n&gt;&gt;&gt; a.z = {1.0, 2.0}\n&gt;&gt;&gt; a.w = [1, 2]\n&gt;&gt;&gt; a\nA(x=[1, 2], y=('1', '2'), z={1.0, 2.0}, w=[1, 2])\n\n&gt;&gt;&gt; a.x = [1, \"2\"]\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '2'\n\n&gt;&gt;&gt; a.x = (1, 2)      # `Sequence` accepts any sequence type\n\n&gt;&gt;&gt; # `Tuple` only accepts tuples\n&gt;&gt;&gt; a.y = [\"1\", \"2\"]  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: error setting `y`: invalid value for type 'typing.Tuple[str]':\n['1', '2']\n</code></pre> <p>The collection length can be controlled by the arguments of the type annotation. Note, however, that <code>typing.Sequence/typing.List/typing.Set</code> do not accept multiple arguments, and so, cannot be used if collection length has to be specified. On Python &lt; 3.9, only <code>typing.Tuple</code> can be used for controlling collection lengths.</p> <p>To specify that a collection must be non-empty, use ellipsis (<code>...</code>) as the second argument of the type::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Tuple[int, ...]\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = tuple()  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: expected non-empty collection for type\n'typing.Tuple[int, ...]'\n</code></pre> <p>Collections can also be restricted to be of a fixed length::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Tuple[int, str]\n...     y: Tuple[int, int, int]\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = (1, 1)\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'str'&gt;': 1\n\n&gt;&gt;&gt; a.y = (1, 1)  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: error setting `y`: invalid value for type\n'typing.Tuple[int, int, int]': (1, 1): expected exactly '3' elements\n</code></pre> <p>Literals <code>typing.Literal</code> can be used to specify that an attribute takes one of a fixed set of values::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Literal[0, 1, \"2\"]\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = 0\n&gt;&gt;&gt; a.x = \"2\"\n&gt;&gt;&gt; a.x = \"1\"  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type\n'typing.Literal[0, 1, '2']': '1'\n</code></pre> <p>Type annotations can be nested; for instance, <code>Sequence[Literal[0, 1, 2], Literal[0, 1, 2]]</code> represents a sequence of length 2, where each element is either 0, 1, or 2.</p> <p>A fixed set of attribute values can also be specified by adding a <code>__choices__</code> attribute to the argument type, containing a collection of choices::</p> <pre><code>&gt;&gt;&gt; class T(int):\n...     __choices__ = (1, 2)\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: T\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = 1\n&gt;&gt;&gt; a.x = 3  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'T'&gt;': 3:\nexpected one of: (1, 2)\n</code></pre> <p>Note that choices specified in this way are not type-checked to ensure that they match the argument type; in the above example, <code>__choices__</code> could be set to <code>(1, \"2\")</code>.</p> <p>Self <code>Corgy</code> classes can have attributes of their own type, annotated using <code>typing.Self</code>.</p> <pre><code>&gt;&gt;&gt; if sys.version_info &gt;= (3, 11):\n...     from typing import Self\n... else:\n...     from typing_extensions import Self\n\n&gt;&gt;&gt; class C(Corgy):\n...     x: int\n...     c: Self\n\n&gt;&gt;&gt; c = C(x=1)\n&gt;&gt;&gt; c.c = C(x=2)\n&gt;&gt;&gt; c\nC(x=1, c=C(x=2))\n\n&gt;&gt;&gt; class D(C):\n...     ...\n\n&gt;&gt;&gt; c.c = D(x=3)  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: error setting `c`: invalid value for type 'Self (bound to\n&lt;class 'C'&gt;)': D(x=3)\n</code></pre> Source code in <code>corgy/_corgy.py</code> <pre><code>class Corgy(metaclass=CorgyMeta):\n\"\"\"Base class for collections of attributes.\n\n    To use, subclass `Corgy`, and declare attributes using type annotations::\n\n        &gt;&gt;&gt; from corgy import Corgy\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: int\n        ...     y: float\n\n    At runtime, class `A` will have `x`, and `y` as properties, so that the class can be\n    used similar to Python dataclasses::\n\n        &gt;&gt;&gt; a = A()\n        &gt;&gt;&gt; a.x = 1\n        &gt;&gt;&gt; a.x\n        1\n\n        &gt;&gt;&gt; a.y\n        Traceback (most recent call last):\n           ...\n        AttributeError: no value available for attribute `y`\n\n        &gt;&gt;&gt; a.y = a.x + 1.1\n        &gt;&gt;&gt; a.y\n        2.1\n\n        &gt;&gt;&gt; del a.x  # unset x\n        &gt;&gt;&gt; a.x\n        Traceback (most recent call last):\n           ...\n        AttributeError: no value available for attribute `x`\n\n    Note that the class's `__init__` method only accepts keyword arguments, and ignores\n    arguments without a corresponding attribute. The following are all valid::\n\n        &gt;&gt;&gt; A(x=1, y=2.1)\n        A(x=1, y=2.1)\n\n        &gt;&gt;&gt; A(x=1, z=3)  # y is not set, and z is ignored\n        A(x=1)\n\n        &gt;&gt;&gt; A(**{\"x\": 1, \"y\": 2.1, \"z\": 3})\n        A(x=1, y=2.1)\n\n    Attribute values are type-checked, and `ValueError` is raised on type mismatch::\n\n        &gt;&gt;&gt; a = A(x=\"1\")\n        Traceback (most recent call last):\n            ...\n        ValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n\n        &gt;&gt;&gt; a = A()\n        &gt;&gt;&gt; a.x = \"1\"\n        Traceback (most recent call last):\n            ...\n        ValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: int = \"1\"\n        Traceback (most recent call last):\n            ...\n        ValueError: default value type mismatch for 'x'\n\n    Any type which supports type checking with `isinstance` can be used as an\n    attribute type (along with some special type annotations that are discussed below).\n    This includes other corgy classes::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: int\n        ...     y: float\n\n        &gt;&gt;&gt; class B(Corgy):\n        ...     x: int\n        ...     a: A\n\n        &gt;&gt;&gt; b = B(x=1)\n        &gt;&gt;&gt; b.a = A()\n        &gt;&gt;&gt; b.a.x = 10\n        &gt;&gt;&gt; b\n        B(x=1, a=A(x=10))\n\n    `Corgy` classes have their `__slots__` set to the annotated attributes. So, if you\n    want to use additional attributes not tracked by `Corgy`, define them (and only\n    them) in `__slots__`::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     __slots__ = (\"x\",)\n        ...     y: int\n\n        &gt;&gt;&gt; a = A()\n        &gt;&gt;&gt; a.y = 1  # `Corgy` attribute\n        &gt;&gt;&gt; a.x = 2  # custom attribute\n        &gt;&gt;&gt; a\n        A(y=1)\n\n    To allow arbitrary instance attributes, add `__dict__` to `__slots__`. Names added\n    through custom `__slots__` are not processed by `Corgy`. Alternatively, to disable\n    setting `__slots__` completely, set `corgy_make_slots` to `False` in the class\n    definition::\n\n        &gt;&gt;&gt; class A(Corgy, corgy_make_slots=False):\n        ...     y: int\n\n        &gt;&gt;&gt; a = A()\n        &gt;&gt;&gt; a.y = 1  # `Corgy` attribute\n        &gt;&gt;&gt; a.x = 2  # custom attribute\n        &gt;&gt;&gt; a\n        A(y=1)\n\n    Names marked with the `ClassVar` type will be added as class variables, and will\n    not be available as `Corgy` attributes::\n\n        &gt;&gt;&gt; from typing import ClassVar\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: ClassVar[int] = 3\n\n        &gt;&gt;&gt; A.x\n        3\n        &gt;&gt;&gt; A.x = 4\n        &gt;&gt;&gt; A.x\n        4\n        &gt;&gt;&gt; a = A()\n        &gt;&gt;&gt; a.x\n        4\n        &gt;&gt;&gt; a.x = 5\n        Traceback (most recent call last):\n            ...\n        AttributeError: 'A' object attribute 'x' is read-only\n\n    Also note that class variables need to be assigned to a value during definition, and\n    this value will not be type checked by `Corgy`.\n\n    Inheritance works as expected, whether base classes are themselves `Corgy` classes\n    or not, with sub-classes inheriting the attributes of the base class, and overriding\n    any redefined attributes::\n\n        &gt;&gt;&gt; class A:\n        ...     x: int\n\n        &gt;&gt;&gt; class B(Corgy, A):\n        ...     y: float = 1.0\n        ...     z: str\n\n        &gt;&gt;&gt; class C(B):\n        ...     y: float = 2.0\n        ...     z: str\n        ...     w: float\n\n        &gt;&gt;&gt; c = C()\n        &gt;&gt;&gt; print(c)\n        C(x=&lt;unset&gt;, y=2.0, z=&lt;unset&gt;, w=&lt;unset&gt;)\n\n    Tracking of base class attributes can be disabled by setting `corgy_track_bases` to\n    `False` in the class definition. Properties will still be inherited following\n    standard inheritance rules, but `Corgy` will ignore them::\n\n        &gt;&gt;&gt; class A:\n        ...     x: int\n\n        &gt;&gt;&gt; class B(Corgy, A, corgy_track_bases=False):\n        ...     y: float = 1.0\n        ...     z: str\n\n        &gt;&gt;&gt; b = B()\n        &gt;&gt;&gt; print(b)\n        B(y=1.0, z=&lt;unset&gt;)\n\n    `Corgy` instances can be frozen (preventing any further changes) using the `freeze`\n    method. This method can be called automatically after `__init__` by by setting\n    `corgy_freeze_after_init` to `True` in the class definition::\n\n        &gt;&gt;&gt; class A(Corgy, corgy_freeze_after_init=True):\n        ...    x: int\n\n        &gt;&gt;&gt; a = A(x=1)\n        &gt;&gt;&gt; a.x = 2\n        Traceback (most recent call last):\n            ...\n        TypeError: cannot set `x`: object is frozen\n\n    `Corgy` recognizes a number of special annotations, which are used to control how\n    attribute values are processed.\n\n    Note:\n        If any of the following annotations are unavailable in the Python version being\n        used, you can import them from `typing_extensions` (which is available on PyPI).\n\n    *Annotations*\n    `typing.Annotated` can be used to add additional metadata to attributes, akin to\n    doc strings. It is primarily used to control how attributes are added to\n    `ArgumentParser` instances. `typing.Annotated` is stripped on class creation,\n    leaving only the base type::\n\n        &gt;&gt;&gt; import sys\n        &gt;&gt;&gt; if sys.version_info &gt;= (3, 9):\n        ...     from typing import Annotated, Literal\n        ... else:\n        ...     from typing_extensions import Annotated, Literal\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Annotated[int, \"this is x\"]\n\n        &gt;&gt;&gt; A.attrs()\n        {'x': &lt;class 'int'&gt;}\n\n    `Annotated` should always be the outermost type annotation for an attribute.\n    Refer to the docs for `Corgy.add_args_to_parser` for details on usage.\n\n    *Required/NotRequired*\n    By default, `Corgy` attributes are not required, and can be unset. This can be\n    changed by setting `corgy_required_by_default` to `True` in the class definition::\n\n        &gt;&gt;&gt; class A(Corgy, corgy_required_by_default=True):\n        ...     x: int\n\n        &gt;&gt;&gt; A()\n        Traceback (most recent call last):\n            ...\n        ValueError: missing required attribute: `x`\n        &gt;&gt;&gt; a = A(x=1)\n        &gt;&gt;&gt; del a.x\n        Traceback (most recent call last):\n            ...\n        TypeError: attribute `x` cannot be unset\n\n    Attributes can also explicitly be marked as required/not-required using\n    `corgy.Required` and `corgy.NotRequired` annotations::\n\n        &gt;&gt;&gt; from corgy import Required, NotRequired\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Required[int]\n        ...     y: NotRequired[int]\n        ...     z: int  # not required by default\n\n        &gt;&gt;&gt; a = A(x=1)\n        &gt;&gt;&gt; print(a)\n        A(x=1, y=&lt;unset&gt;, z=&lt;unset&gt;)\n\n        &gt;&gt;&gt; class B(Corgy, corgy_required_by_default=True):\n        ...     x: Required[int]\n        ...     y: NotRequired[int]\n        ...     z: int\n\n        &gt;&gt;&gt; b = B(x=1, z=2)\n        &gt;&gt;&gt; print(b)\n        B(x=1, y=&lt;unset&gt;, z=2)\n\n    *Optional*\n    Annotating an attribute with `typing.Optional` allows it to be `None`::\n\n        &gt;&gt;&gt; from typing import Optional\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Optional[int]\n\n        &gt;&gt;&gt; a = A()\n        &gt;&gt;&gt; a.x = None\n\n    In Python &gt;= 3.10, instead of using `typing.Annotated`, `| None` can be used, i.e.,\n    `x: int | None` for example.\n\n    Note that `Optional` is not the same as `NotRequired`. `Optional` allows an\n    attribute to be `None`, while `NotRequired` allows an attribute to be unset.\n    A `Required` `Optional` attribute will need a value (which can be `None`)::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Required[Optional[int]]\n\n        &gt;&gt;&gt; A()\n        Traceback (most recent call last):\n            ...\n        ValueError: missing required attribute: `x`\n        &gt;&gt;&gt; a = A(x=None)\n        &gt;&gt;&gt; print(a)\n        A(x=None)\n\n    *Collections*\n    Several collection types can be used to annotate attributes, which will restrict the\n    type of accepted values. Values in the collection will be checked to ensure that\n    they match the annotated collection types. The following collection types are\n    supported:\n\n    1. `collections.abc.Sequence` (`typing.Sequence` on Python &lt; 3.9)\n    2. `tuple` (`typing.Tuple` on Python &lt; 3.9)\n    3. `list` (`typing.List` on Python &lt; 3.9)\n    4. `set` (`typing.Set` on Python &lt; 3.9)\n\n    There are a few different ways to use these types, each resulting in different\n    validation conditions. The simplest case is a plain (possibly empty) collection of a\n    single type::\n\n        &gt;&gt;&gt; from typing import List, Sequence, Set, Tuple\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Sequence[int]\n        ...     y: Tuple[str]\n        ...     z: Set[float]\n        ...     w: List[int]\n\n        &gt;&gt;&gt; a = A()\n        &gt;&gt;&gt; a.x = [1, 2]\n        &gt;&gt;&gt; a.y = (\"1\", \"2\")\n        &gt;&gt;&gt; a.z = {1.0, 2.0}\n        &gt;&gt;&gt; a.w = [1, 2]\n        &gt;&gt;&gt; a\n        A(x=[1, 2], y=('1', '2'), z={1.0, 2.0}, w=[1, 2])\n\n        &gt;&gt;&gt; a.x = [1, \"2\"]\n        Traceback (most recent call last):\n            ...\n        ValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '2'\n\n        &gt;&gt;&gt; a.x = (1, 2)      # `Sequence` accepts any sequence type\n\n        &gt;&gt;&gt; # `Tuple` only accepts tuples\n        &gt;&gt;&gt; a.y = [\"1\", \"2\"]  # doctest: +NORMALIZE_WHITESPACE\n        Traceback (most recent call last):\n            ...\n        ValueError: error setting `y`: invalid value for type 'typing.Tuple[str]':\n        ['1', '2']\n\n    The collection length can be controlled by the arguments of the type annotation.\n    Note, however, that `typing.Sequence/typing.List/typing.Set` do not\n    accept multiple arguments, and so, cannot be used if collection length has to be\n    specified. On Python &lt; 3.9, only `typing.Tuple` can be used for controlling\n    collection lengths.\n\n    To specify that a collection must be non-empty, use ellipsis (`...`) as the second\n    argument of the type::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Tuple[int, ...]\n\n        &gt;&gt;&gt; a = A()\n        &gt;&gt;&gt; a.x = tuple()  # doctest: +NORMALIZE_WHITESPACE\n        Traceback (most recent call last):\n            ...\n        ValueError: error setting `x`: expected non-empty collection for type\n        'typing.Tuple[int, ...]'\n\n    Collections can also be restricted to be of a fixed length::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Tuple[int, str]\n        ...     y: Tuple[int, int, int]\n\n        &gt;&gt;&gt; a = A()\n        &gt;&gt;&gt; a.x = (1, 1)\n        Traceback (most recent call last):\n            ...\n        ValueError: error setting `x`: invalid value for type '&lt;class 'str'&gt;': 1\n\n        &gt;&gt;&gt; a.y = (1, 1)  # doctest: +NORMALIZE_WHITESPACE\n        Traceback (most recent call last):\n            ...\n        ValueError: error setting `y`: invalid value for type\n        'typing.Tuple[int, int, int]': (1, 1): expected exactly '3' elements\n\n    *Literals*\n    `typing.Literal` can be used to specify that an attribute takes one of a fixed set\n    of values::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Literal[0, 1, \"2\"]\n\n        &gt;&gt;&gt; a = A()\n        &gt;&gt;&gt; a.x = 0\n        &gt;&gt;&gt; a.x = \"2\"\n        &gt;&gt;&gt; a.x = \"1\"  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n            ...\n        ValueError: error setting `x`: invalid value for type\n        'typing.Literal[0, 1, '2']': '1'\n\n    Type annotations can be nested; for instance,\n    `Sequence[Literal[0, 1, 2], Literal[0, 1, 2]]` represents a sequence of length 2,\n    where each element is either 0, 1, or 2.\n\n    A fixed set of attribute values can also be specified by adding a `__choices__`\n    attribute to the argument type, containing a collection of choices::\n\n        &gt;&gt;&gt; class T(int):\n        ...     __choices__ = (1, 2)\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: T\n\n        &gt;&gt;&gt; a = A()\n        &gt;&gt;&gt; a.x = 1\n        &gt;&gt;&gt; a.x = 3  # doctest: +NORMALIZE_WHITESPACE\n        Traceback (most recent call last):\n            ...\n        ValueError: error setting `x`: invalid value for type '&lt;class 'T'&gt;': 3:\n        expected one of: (1, 2)\n\n    Note that choices specified in this way are not type-checked to ensure that they\n    match the argument type; in the above example, `__choices__` could be set to\n    `(1, \"2\")`.\n\n    *Self*\n    `Corgy` classes can have attributes of their own type, annotated using\n    `typing.Self`.\n\n        &gt;&gt;&gt; if sys.version_info &gt;= (3, 11):\n        ...     from typing import Self\n        ... else:\n        ...     from typing_extensions import Self\n\n        &gt;&gt;&gt; class C(Corgy):\n        ...     x: int\n        ...     c: Self\n\n        &gt;&gt;&gt; c = C(x=1)\n        &gt;&gt;&gt; c.c = C(x=2)\n        &gt;&gt;&gt; c\n        C(x=1, c=C(x=2))\n\n        &gt;&gt;&gt; class D(C):\n        ...     ...\n\n        &gt;&gt;&gt; c.c = D(x=3)  # doctest: +NORMALIZE_WHITESPACE\n        Traceback (most recent call last):\n            ...\n        ValueError: error setting `c`: invalid value for type 'Self (bound to\n        &lt;class 'C'&gt;)': D(x=3)\n\n    \"\"\"\n\n    @classmethod\n    def add_args_to_parser(\n        cls,\n        parser: _ActionsContainer,\n        name_prefix: str = \"\",\n        flatten_subgrps: bool = False,\n        defaults: Optional[Mapping[str, Any]] = None,\n    ):\n\"\"\"Add the class' `Corgy` attributes to the given parser.\n\n        Args:\n            parser: Argument parser/group to which the attributes will be added.\n            name_prefix: Prefix for argument names. Arguments will be named\n                `--&lt;name-prefix&gt;:&lt;attr-name&gt;`. If custom flags are present,\n                `--&lt;name-prefix&gt;:&lt;flag&gt;` will be used instead (one for each flag).\n            flatten_subgrps: Whether to add sub-groups to the main parser instead of\n                creating argument groups. Note: sub-sub-groups are always added with\n                this argument set to `True`, since `argparse` in unable to properly\n                display nested group arguments.\n            defaults: Optional mapping with default values for arguments. Any value\n                specified here will override default values specified in the class.\n                Values for groups can be specified either as `Corgy` instances, or as\n                individual values using the same syntax as for `Corgy.from_dict`.\n\n        Type annotations control how attributes are added to the parser. A number of\n        special annotations are parsed and stripped from attribute types to determine\n        the parameters for calling `ArgumentParser.add_argument`. These special\n        annotations are described below.\n\n        Note: `add_args_to_parser` cannot be used if the type annotation for any\n        attribute of the class includes `Self`, unless a custom parser is defined\n        for such attributes. See docs for `corgyparser` on how to define custom\n        parsers.\n\n        *Annotated*\n        `typing.Annotated` can be used to add a help message for the argument::\n\n            &gt;&gt;&gt; import argparse\n            &gt;&gt;&gt; from argparse import ArgumentParser\n            &gt;&gt;&gt; from corgy import CorgyHelpFormatter\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: Annotated[int, \"help for x\"]\n\n            &gt;&gt;&gt; parser = ArgumentParser(\n            ...     formatter_class=CorgyHelpFormatter,\n            ...     add_help=False,\n            ...     usage=argparse.SUPPRESS,\n            ... )\n\n            &gt;&gt;&gt; A.add_args_to_parser(parser)\n            &gt;&gt;&gt; parser.print_help()\n            options:\n              --x int  help for x (optional)\n\n        This annotation can also be used to modify the parser flags for the argument. By\n        default, the attribute name is used, prefixed with `--`, and with `_` replaced\n        by `-`. If the custom flag does not have a leading `-`, a positional argument\n        will be created::\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: Annotated[int, \"help for x\", [\"-x\", \"--ex\"]]\n            ...     y: Annotated[int, \"help for y\", [\"y\"]]\n\n            &gt;&gt;&gt; parser = ArgumentParser(\n            ...     formatter_class=CorgyHelpFormatter,\n            ...     add_help=False,\n            ...     usage=argparse.SUPPRESS,\n            ... )\n\n            &gt;&gt;&gt; A.add_args_to_parser(parser)\n            &gt;&gt;&gt; parser.print_help()\n            positional arguments:\n              y int        help for y\n            &lt;BLANKLINE&gt;\n            options:\n              -x/--ex int  help for x (optional)\n\n        `Annotated` can accept multiple arguments, but only the first three are used\n        by `Corgy`. The first argument is the attribute type, the second is the help\n        message (which must be a string), and the third is a sequence of flags.\n\n        *Required/NotRequired*\n        Every corgy attribute is either required or not required. The default status\n        depends on the class parameter `corgy_required_by_default` (`False` by default).\n        Attributes can also be explicitly marked as required or not required, and will\n        control whether the argument will be added with `required=True`::\n\n            &gt;&gt;&gt; from corgy import Required, NotRequired\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: Required[int]\n            ...     y: NotRequired[int]\n            ...     z: int\n\n            &gt;&gt;&gt; parser = ArgumentParser(\n            ...     formatter_class=CorgyHelpFormatter,\n            ...     add_help=False,\n            ...     usage=argparse.SUPPRESS,\n            ... )\n\n            &gt;&gt;&gt; A.add_args_to_parser(parser)\n            &gt;&gt;&gt; parser.print_help()\n            options:\n              --x int  (required)\n              --y int  (optional)\n              --z int  (optional)\n\n        Attributes which are not required, and don't have a default value are added\n        with `default=argparse.SUPPRESS`, and so will not be in the parsed namespace::\n\n            &gt;&gt;&gt; parser.parse_args([\"--x\", \"1\", \"--y\", \"2\"])\n            Namespace(x=1, y=2)\n\n        *Optional*\n        Attributes marked with `typing.Optional` are allowed to be `None`. The\n        arguments for these attributes can be passed with no values (i.e. `--x`\n        instead of `--x=1` or `--x 1`) to indicate that the value should be `None`.\n\n        Note: Attributes with default values are also \"optional\" in the sense that\n        they can be omitted from the command line. However, they are not the same as\n        attributes marked with `Optional`, since the former are not allowed to be\n        `None`. Furthermore, `Required` `Optional` attributes without default values\n        _will_ need to be passed on the command line (possibly with no values).\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: Required[Optional[int]]\n\n            &gt;&gt;&gt; parser = ArgumentParser()\n            &gt;&gt;&gt; A.add_args_to_parser(parser)\n            &gt;&gt;&gt; parser.parse_args([\"--x\"])\n            Namespace(x=None)\n\n        *Boolean*\n        `bool` types (when not in a collection) are converted to a pair of options::\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     arg: bool\n\n            &gt;&gt;&gt; parser = ArgumentParser(\n            ...     formatter_class=CorgyHelpFormatter,\n            ...     add_help=False,\n            ...     usage=argparse.SUPPRESS,\n            ... )\n\n            &gt;&gt;&gt; A.add_args_to_parser(parser)\n            &gt;&gt;&gt; parser.print_help()\n            options:\n              --arg/--no-arg\n\n        *Collection*\n        Collection types are added to the parser by setting `nargs`. The value for\n        `nargs` is determined by the collection type. Plain collections, such as\n        `Sequence[int]`, will be added with `nargs=*`; Non-empty collections, such as\n        `Sequence[int, ...]`, will be added with `nargs=+`; Finally, fixed-length\n        collections, such as `Sequence[int, int, int]`, will be added with `nargs` set\n        to the length of the collection.\n\n        In all cases, collection types can only be added to a parser if they are single\n        type. Heterogenous collections, such as `Sequence[int, str]` cannot be added,\n        and will raise `ValueError`. Untyped collections (e.g., `x: Sequence`), also\n        cannot be added.\n\n        Arguments for optional collections will also accept no values to indicate\n        `None`. Due to this, it is not possible to parse an empty collection for\n        an optional collection argument::\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: Optional[Sequence[int]]\n            ...     y: Sequence[int]\n\n            &gt;&gt;&gt; parser = ArgumentParser()\n            &gt;&gt;&gt; A.add_args_to_parser(parser)\n            &gt;&gt;&gt; parser.parse_args([\"--x\", \"--y\"])\n            Namespace(x=None, y=[])\n\n        *Literal*\n        For `Literal` types, the provided values are passed to the `choices` argument\n        of `ArgumentParser.add_argument`. All values must be of the same type, which\n        will be inferred from the type of the first value. If the first value has a\n        `__bases__` attribute, the type will be inferred as the first base type, and\n        all other choices must be subclasses of that type::\n\n            &gt;&gt;&gt; class T: ...\n            &gt;&gt;&gt; class T1(T): ...\n            &gt;&gt;&gt; class T2(T): ...\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: Literal[T1, T2]\n\n            &gt;&gt;&gt; parser = ArgumentParser(\n            ...     formatter_class=CorgyHelpFormatter,\n            ...     add_help=False,\n            ...     usage=argparse.SUPPRESS,\n            ... )\n\n            &gt;&gt;&gt; A.add_args_to_parser(parser)\n            &gt;&gt;&gt; parser.print_help()\n            options:\n              --x T  ({T1/T2} optional)\n\n        For types which specify choices by defining `__choices__`, the values are\n        passed to the `choices` argument as with `Literal`, but no type inference is\n        performed, and the base attribute type will be used as the argument type.\n\n        **Single-value Literals**\n        A special case for `Literal` types is when there is only one choice. In this\n        case, the argument is added as a `store_const` action, with the value as the\n        `const` argument. A further special case is when the choice is `True/False`,\n        in which case the action is `store_true`/`store_false` respectively::\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: Literal[True]\n            ...     y: Literal[False]\n            ...     z: Literal[42]\n\n            &gt;&gt;&gt; parser = ArgumentParser()\n            &gt;&gt;&gt; A.add_args_to_parser(parser)\n            &gt;&gt;&gt; parser.parse_args([\"--x\"])  # Note that `y` and `z` are absent\n            Namespace(x=True)\n            &gt;&gt;&gt; parser.parse_args([\"--y\"])\n            Namespace(y=False)\n            &gt;&gt;&gt; parser.parse_args([\"--z\"])\n            Namespace(z=42)\n\n        Note: This special case only applies to `Literal` types, and not types which\n        define `__choices__`.\n\n        *Corgy*\n        Attributes which are themselves `Corgy` types are treated as argument groups.\n        Group arguments are added to the command line parser with the group attribute\n        name prefixed. Note that groups will ignore any custom flags when computing the\n        prefix; elements within the group will use custom flags, but because they are\n        prefixed with `--`, they will not be positional.\n\n        Example::\n\n            &gt;&gt;&gt; class G(Corgy):\n            ...     x: int = 0\n            ...     y: float\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: int\n            ...     g: G\n\n            &gt;&gt;&gt; parser = ArgumentParser(\n            ...     formatter_class=CorgyHelpFormatter,\n            ...     add_help=False,\n            ...     usage=argparse.SUPPRESS,\n            ... )\n\n            &gt;&gt;&gt; A.add_args_to_parser(parser)\n            &gt;&gt;&gt; parser.print_help()\n            options:\n              --x int      (optional)\n            &lt;BLANKLINE&gt;\n            g:\n              --g:x int    (default: 0)\n              --g:y float  (optional)\n\n        **Custom parsers**\n\n        Attributes for which a custom parser is defined using `@corgyparser` will\n        be added with a custom action that will call the parser. Refer to the\n        documentation for `corgyparser` for details.\n\n        **Metavar**\n\n        This function will not explicitly pass a value for the `metavar` argument of\n        `ArgumentParser.add_argument`, unless an attribute's type defines `__metavar__`,\n        in which case, it will be passed as is. To change the metavar for attributes\n        with custom parsers, set the `metavar` argument of `corgyparser`.\n        \"\"\"\n        base_parser = parser\n        base_defaults = getattr(cls, \"__defaults\").copy()\n        if defaults is not None:\n            base_defaults.update(defaults)\n\n        # Extract default values for group arguments specified individually using\n        # the `&lt;group&gt;:&lt;var name&gt;` syntax.\n        group_arg_defaults: Dict[str, Dict[str, Any]] = defaultdict(dict)\n        for _k, _v in base_defaults.items():\n            if \":\" in _k:\n                _grp_name, _var_name = _k.split(\":\")\n                group_arg_defaults[_grp_name][_var_name] = _v\n            elif _k not in cls.__annotations__:\n                raise ValueError(f\"default value for unknown argument: `{_k}`\")\n\n        required_attrs = getattr(cls, \"__required\")\n        custom_flags = getattr(cls, \"__flags\")\n        custom_parsers = getattr(cls, \"__parsers\")\n\n        @dataclass\n        class _Arg:\n            name: str\n            required: Optional[bool] = None\n            positional: Optional[bool] = None\n            dest: Optional[str] = None\n            flags: Optional[Sequence[str]] = None\n            help: Optional[str] = None\n            nargs: Union[int, Literal[\"+\", \"*\"], None] = None\n            action: Optional[Type[argparse.Action]] = None\n            choices: Optional[Sequence[Any]] = None\n            metavar: Optional[str] = None\n            add_type: Optional[Any] = None\n            const: Optional[Any] = None\n\n            def get_add_kwargs(self) -&gt; Dict[str, Any]:\n                assert self.required is not None\n                assert self.positional is not None\n                assert self.dest is not None\n                kwargs: Dict[str, Any] = {}\n                if (not self.positional) and (self.name in custom_flags):\n                    kwargs[\"dest\"] = self.dest\n                if self.help is not None:\n                    kwargs[\"help\"] = self.help\n                if self.nargs is not None:\n                    kwargs[\"nargs\"] = self.nargs\n                if self.action is not None:\n                    kwargs[\"action\"] = self.action\n                if self.choices is not None:\n                    kwargs[\"choices\"] = self.choices\n\n                if self.name in base_defaults:\n                    kwargs[\"default\"] = base_defaults[self.name]\n                elif self.required and not self.positional:\n                    kwargs[\"required\"] = True\n                elif not self.positional:\n                    kwargs[\"default\"] = argparse.SUPPRESS\n\n                if self.metavar is not None:\n                    kwargs[\"metavar\"] = self.metavar\n                if self.add_type is not None:\n                    kwargs[\"type\"] = self.add_type\n                if self.const is not None:\n                    kwargs[\"const\"] = self.const\n\n                return kwargs\n\n            def process_optional(self, type_) -&gt; Any:\n                if is_optional_type(type_):\n                    self.action = OptionalTypeAction\n                    return type_.__args__[0]\n                return type_\n\n            def process_collection(self, type_) -&gt; Any:\n                _col_type = get_concrete_collection_type(type_)\n                if _col_type is not None:\n                    if (\n                        not hasattr(type_, \"__args__\")\n                        or not type_.__args__\n                        or isinstance(type_.__args__[0], TypeVar)\n                    ):\n                        raise TypeError(\n                            f\"`{self.name}` is a collection, but has no type arguments:\"\n                            f\" use `{type_}[&lt;types&gt;]\"\n                        )\n                    if len(type_.__args__) == 1:\n                        self.nargs = \"*\"\n                    elif len(type_.__args__) == 2 and type_.__args__[1] is Ellipsis:\n                        # `...` is used to represent non-empty collections, e.g.,\n                        # `Sequence[int, ...]`.\n                        self.nargs = \"+\"\n                    else:\n                        # Ensure single type.\n                        if any(_a != type_.__args__[0] for _a in type_.__args__[1:]):\n                            raise TypeError(\n                                f\"`{self.name}` has unsupported type `{type_}`: only\"\n                                f\" single-type collections are supported\"\n                            )\n                        self.nargs = len(type_.__args__)\n                    return type_.__args__[0]\n                return type_\n\n            def process_choices(self, type_) -&gt; Any:\n                _is_literal_type = is_literal_type(type_)\n                if _is_literal_type:\n                    # Determine if the first choice has `__bases__`, in which case\n                    # the first base class is the type for the argument.\n                    try:\n                        c0_type = type_.__args__[0].__bases__[0]\n                    except AttributeError:\n                        c0_type = type(type_.__args__[0])\n                        f_check_type: Callable[[Any, Any], bool] = isinstance\n                    else:\n                        f_check_type = issubclass\n\n                    # All choices must be of the same type.\n                    if any(not f_check_type(_a, c0_type) for _a in type_.__args__[1:]):\n                        raise TypeError(\n                            f\"choices for `{self.name}` not all of type `{c0_type}`: \"\n                            f\"`{type_.__args__}`\"\n                        )\n                    self.choices = type_.__args__\n\n                    # Convert single choice attributes to `store_*` actions.\n                    if (\n                        self.choices is not None\n                        and len(self.choices) == 1\n                        and self.nargs is None\n                        and self.action is None\n                    ):\n                        _choice = self.choices[0]\n                        if _choice is True:\n                            self.action = _StoreTrueAction\n                        elif _choice is False:\n                            self.action = _StoreFalseAction\n                        else:\n                            self.action = _StoreConstAction\n                            self.const = _choice\n                        self.choices = None\n                        return None\n                    return c0_type\n\n                if hasattr(type_, \"__choices__\"):\n                    self.choices = type_.__choices__\n\n                return type_\n\n        for var_name, var_type in cls.attrs().items():\n            var_arg = _Arg(var_name)\n            var_arg.help = getattr(\n                cls, var_name\n            ).__doc__  # doc is stored in the property\n            var_arg.required = (\n                var_name not in base_defaults and var_name in required_attrs\n            )\n\n            # Determine add flags.\n            var_arg.flags = custom_flags.get(\n                var_name, [f\"--{var_name.replace('_', '-')}\"]\n            )\n            assert var_arg.flags is not None\n            if name_prefix:\n                var_arg.flags = [\n                    f\"--{name_prefix.replace('_', '-')}:{flag.lstrip('-')}\"\n                    for flag in var_arg.flags\n                ]\n                var_arg.dest = f\"{name_prefix}:{var_name}\"\n            else:\n                var_arg.dest = var_name\n\n            # Determine if argument is positional.\n            if not any(_flag.startswith(\"-\") for _flag in var_arg.flags):\n                # Note: the flags cannot be passed to `add_argument` with `dest` set\n                # to `var_name` since `argparse` will raise an error for passing `dest`\n                # twice (for positional arguments, `argparse` uses the flag to infer the\n                # `dest`).\n                var_arg.flags = [var_name]\n                var_arg.positional = True\n            elif all(_flag.startswith(\"-\") for _flag in var_arg.flags):\n                var_arg.positional = False\n            else:\n                raise TypeError(\n                    f\"inconsistent positional/optional flags for {var_name}: \"\n                    f\"{var_arg.flags}\"\n                )\n\n            ###################################################################\n            # Check if the variable has a custom parser.\n            if var_name in custom_parsers:\n                _var_parser = custom_parsers[var_name]\n                _var_base_type = var_type\n                # Extract choices if present.\n                if is_literal_type(var_type):\n                    _var_choices = var_type.__args__\n                    try:\n                        _var_base_type = _var_choices[0].__bases__[0]\n                    except AttributeError:\n                        _var_base_type = type(_var_choices[0])\n                elif hasattr(var_type, \"__choices__\"):\n                    _var_choices = var_type.__choices__\n                else:\n                    _var_choices = None\n\n                var_arg.action = partial(\n                    CorgyParserAction, _var_parser, _var_choices  # type: ignore\n                )\n                var_arg.add_type = str\n                var_arg.nargs = getattr(_var_parser, \"__nargs__\", None)\n                try:\n                    var_arg.metavar = _var_parser.__metavar__\n                except AttributeError:\n                    try:\n                        var_arg.metavar = _var_base_type.__metavar__\n                    except AttributeError:\n                        pass\n                parser.add_argument(*var_arg.flags, **var_arg.get_add_kwargs())\n                continue\n\n            ###################################################################\n            # Check if the variable is also `Corgy` type.\n            if type(var_type) is type(cls):\n                # Create an argument group using `&lt;var_type&gt;`.\n                # If there is a default value, pass it using `**defaults`.\n                if var_name in base_defaults:\n                    try:\n                        grp_defaults = base_defaults[var_name].as_dict()\n                    except AttributeError:\n                        raise ValueError(\n                            f\"default value for `{var_name}` is not a `Corgy` instance\"\n                        ) from None\n                else:\n                    grp_defaults = {}\n\n                # Update defaults with any values specified individually.\n                grp_defaults.update(group_arg_defaults.get(var_name, {}))\n\n                grp_parser: _ActionsContainer\n                if flatten_subgrps:\n                    grp_parser = base_parser\n                else:\n                    grp_parser = base_parser.add_argument_group(\n                        var_arg.dest, var_arg.help\n                    )\n                var_type.add_args_to_parser(\n                    grp_parser, var_arg.dest, True, grp_defaults\n                )\n                continue\n\n            ###################################################################\n            # Check if the variable is boolean. Boolean variables are converted to\n            # `--&lt;var-name&gt;`/`--no-&lt;var-name&gt;` arguments (if not positional).\n            if var_type is bool:\n                var_arg.add_type = bool\n                if not var_arg.positional:\n                    var_arg.action = BooleanOptionalAction\n                parser.add_argument(*var_arg.flags, **var_arg.get_add_kwargs())\n                continue\n\n            ###################################################################\n            # Process annotations.\n            var_base_type = var_type\n            var_base_type = var_arg.process_optional(var_base_type)\n            var_base_type = var_arg.process_collection(var_base_type)\n            var_base_type = var_arg.process_choices(var_base_type)\n\n            if var_base_type is Self:\n                raise TypeError(\n                    \"'add_args_to_parser' cannot be used with 'Self' type present\"\n                )\n\n            var_arg.metavar = getattr(var_base_type, \"__metavar__\", None)\n            var_arg.add_type = var_base_type\n            parser.add_argument(*var_arg.flags, **var_arg.get_add_kwargs())\n\n    def __init__(self, **args):\n        if self.__class__ is Corgy:\n            raise TypeError(\"`Corgy` is an abstract class and cannot be instantiated\")\n\n        setattr(self, f\"_{self.__class__.__name__.lstrip('_')}__frozen\", False)\n\n        cls_attrs = self.attrs()\n        cls_defaults = getattr(self, \"__defaults\")\n        for attr_name in cls_attrs:\n            if attr_name in args:\n                setattr(self, attr_name, args[attr_name])\n            elif attr_name in cls_defaults:\n                setattr(self, attr_name, cls_defaults[attr_name])\n            elif attr_name in getattr(self, \"__required\"):\n                raise ValueError(f\"missing required attribute: `{attr_name}`\")\n\n        if getattr(self.__class__, \"__freeze_after_init\"):\n            self.freeze()\n\n    def _str(self, f_str: Callable[..., str]) -&gt; str:\n        s = f\"{self.__class__.__name__}(\"\n        i = 0\n        for arg_name in self.attrs():\n            try:\n                _val_s = f_str(getattr(self, arg_name))\n            except AttributeError:\n                if f_str is repr:\n                    continue\n                _val_s = \"&lt;unset&gt;\"\n            if i != 0:\n                s = s + \", \"\n            s = s + f\"{arg_name}=\"\n            s = s + _val_s\n            i += 1\n        s = s + \")\"\n        return s\n\n    def __repr__(self) -&gt; str:\n        return self._str(repr)\n\n    def __str__(self) -&gt; str:\n        return self._str(str)\n\n    def __eq__(self, other) -&gt; bool:\n        if other is self:\n            return True\n        if self.__class__ is not other.__class__:\n            return False\n        for _attr in self.attrs():\n            _self_has, _other_has = hasattr(self, _attr), hasattr(other, _attr)\n            if _self_has != _other_has:\n                # One instance has `_attr` set; the other doesn't.\n                return False\n            if not _self_has:\n                # Both instances don't have `_attr` set.\n                continue\n            if getattr(self, _attr) != getattr(other, _attr):\n                return False\n        return True\n\n    @classmethod\n    def attrs(cls) -&gt; Dict[str, Type]:\n\"\"\"Return a dictionary mapping attributes of the class to their types.\n\n        Example::\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: Annotated[int, \"x\"]\n            ...     y: Sequence[str]\n\n            &gt;&gt;&gt; A.attrs()\n            {'x': &lt;class 'int'&gt;, 'y': typing.Sequence[str]}\n\n        \"\"\"\n        return {\n            _attr: getattr(cls, _attr).fget.__annotations__[\"return\"]\n            for _attr in cls.__annotations__\n        }\n\n    def as_dict(self, recursive: bool = True, flatten: bool = False) -&gt; Dict[str, Any]:\n\"\"\"Return the object as a dictionary.\n\n        The returned dictionary maps attribute names to their values. Unset attributes\n        are omitted, unless they have default values.\n\n        Args:\n            recursive: whether to recursively call `as_dict` on attributes which are\n                `Corgy` instances. Otherwise, they are returned as is.\n            flatten: whether to flatten group arguments into `:` separated strings.\n                Only takes effect if `recursive` is `True`.\n\n        Examples::\n\n            &gt;&gt;&gt; class G(Corgy):\n            ...     x: int\n\n            &gt;&gt;&gt; g = G(x=1)\n            &gt;&gt;&gt; g.as_dict()\n            {'x': 1}\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: str\n            ...     g: G\n\n            &gt;&gt;&gt; a = A(x=\"one\", g=g)\n            &gt;&gt;&gt; a.as_dict(recursive=False)\n            {'x': 'one', 'g': G(x=1)}\n            &gt;&gt;&gt; a.as_dict()\n            {'x': 'one', 'g': {'x': 1}}\n            &gt;&gt;&gt; a.as_dict(flatten=True)\n            {'x': 'one', 'g:x': 1}\n\n        \"\"\"\n\n        def dictify_corgys(_val):\n            _coll_type = get_concrete_collection_type(type(_val))\n            if _coll_type is not None:\n                _cast_type = _coll_type if _coll_type is not AbstractSequence else list\n                return _cast_type(  # pylint: disable=abstract-class-instantiated\n                    [dictify_corgys(_val_part) for _val_part in _val]\n                )\n            if isinstance(_val.__class__, CorgyMeta):\n                return _val.as_dict(recursive=True, flatten=flatten)\n            return _val\n\n        self_dict = {}\n        for attr_name, attr_type in self.attrs().items():\n            try:\n                attr_val = getattr(self, attr_name)\n            except AttributeError:\n                continue\n\n            if recursive:\n                attr_val = dictify_corgys(attr_val)\n                if flatten and (isinstance(attr_type, CorgyMeta) or attr_type is Self):\n                    for _k, _v in attr_val.items():\n                        _flat_key = f\"{attr_name}:{_k}\"\n                        self_dict[_flat_key] = _v\n                    continue\n\n            self_dict[attr_name] = attr_val\n\n        return self_dict\n\n    @classmethod\n    def from_dict(cls: Type[_T], d: Mapping[str, Any], try_cast: bool = False) -&gt; _T:\n\"\"\"Return a new instance of the class using a dictionary.\n\n        This is roughly equivalent to `cls(**d)`, with the main exception being that\n        groups can be specified as dictionaries themselves, and will be processed\n        recursively.\n\n        Args:\n            d: Dictionary to create the instance from.\n            try_cast: Whether to try and cast values which don't match attribute types.\n\n        Example::\n\n            &gt;&gt;&gt; class G(Corgy):\n            ...     x: int\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: str\n            ...     g: G\n\n            &gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g\": G(x=1)})\n            A(x='one', g=G(x=1))\n            &gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g\": {\"x\": 1}})\n            A(x='one', g=G(x=1))\n            &gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g\": {\"x\": \"1\"}}, try_cast=True)\n            A(x='one', g=G(x=1))\n            &gt;&gt;&gt; G.from_dict({\"x\": \"1\"})\n            Traceback (most recent call last):\n                ...\n            ValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n\n        Group attributes can also be passed directly in the dictionary by prefixing\n        their names with the group name and a colon::\n\n            &gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g:x\": 1})\n            A(x='one', g=G(x=1))\n\n            &gt;&gt;&gt; class B(Corgy):\n            ...     x: float\n            ...     a: A\n\n            &gt;&gt;&gt; B.from_dict({\"x\": 1.1, \"a:x\": \"one\", \"a:g:x\": 1})\n            B(x=1.1, a=A(x='one', g=G(x=1)))\n\n        \"\"\"\n        main_args_map = {}\n        grp_args_map: Dict[str, Any] = defaultdict(dict)\n        cls_attrs = cls.attrs()\n\n        for arg_name, arg_val in d.items():\n            if \":\" in arg_name:\n                grp_name, arg_name_base = arg_name.split(\":\", maxsplit=1)\n                if not hasattr(cls, grp_name):\n                    raise ValueError(\n                        f\"invalid argument `{arg_name}`: \"\n                        f\"`{cls}` has no group named `{grp_name}`\"\n                    )\n                if grp_name in d:\n                    raise ValueError(\n                        f\"conflicting arguments: `{arg_name}` and `{grp_name}`\"\n                    )\n                grp_type = cls_attrs[grp_name]\n                if not isinstance(grp_type, CorgyMeta):\n                    raise ValueError(f\"`{grp_name}` is not a `Corgy` class\")\n                grp_args_map[grp_name][arg_name_base] = arg_val\n\n            elif hasattr(cls, arg_name):\n                arg_type = cls_attrs[arg_name]\n                if isinstance(arg_type, CorgyMeta) and isinstance(arg_val, dict):\n                    grp_args_map[arg_name] = arg_val\n                else:\n                    main_args_map[arg_name] = arg_val\n\n        for grp_name, grp_args in grp_args_map.items():\n            grp_type = cls_attrs[grp_name]\n            main_args_map[grp_name] = grp_type.from_dict(grp_args, try_cast)\n\n        cls_attrs = cls.attrs()\n        for arg_name, arg_val in main_args_map.copy().items():\n            if arg_name in cls_attrs:\n                try:\n                    main_args_map[arg_name] = check_val_type(\n                        arg_val,\n                        cls_attrs[arg_name],\n                        try_cast,\n                        try_load_corgy_dicts=True,\n                        self_type=cls,\n                    )\n                except ValueError as e:\n                    raise ValueError(f\"error setting `{arg_name}`: {e}\") from None\n        return cls(**main_args_map)\n\n    def load_dict(\n        self, d: Dict[str, Any], try_cast: bool = False, strict: bool = False\n    ) -&gt; None:\n\"\"\"Load a dictionary into an instance of the class.\n\n        Previous attributes are overwritten. Sub-dictionaries will be parsed\n        recursively if the corresponding attribute already exists, else will be parsed\n        using `from_dict`. As with `from_dict`, items in the dictionary without\n        corresponding attributes are ignored.\n\n        Args:\n            d: Dictionary to load.\n            try_cast: Whether to try and cast values which don't match attribute types.\n            strict: If `True`, attributes with existing values that are not in the\n                dictionary will be unset.\n\n        Example::\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: int\n            ...     y: str\n            &gt;&gt;&gt; a = A(x=1)\n            &gt;&gt;&gt; _i = id(a)\n            &gt;&gt;&gt; a.load_dict({\"y\": \"two\"})\n            &gt;&gt;&gt; a\n            A(x=1, y='two')\n            &gt;&gt;&gt; _i == id(a)\n            True\n            &gt;&gt;&gt; a.load_dict({\"y\": \"three\"}, strict=True)\n            &gt;&gt;&gt; a\n            A(y='three')\n            &gt;&gt;&gt; _i == id(a)\n            True\n            &gt;&gt;&gt; a = A()\n            &gt;&gt;&gt; a.load_dict({\"x\": \"1\"})\n            Traceback (most recent call last):\n                ...\n            ValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n            &gt;&gt;&gt; a.load_dict({\"x\": \"1\"}, try_cast=True)\n            &gt;&gt;&gt; a\n            A(x=1)\n\n        \"\"\"\n        main_args_map: Dict[str, Any] = defaultdict(dict)\n        cls_attrs = self.attrs()\n\n        for arg_name, arg_val in d.items():\n            if \":\" in arg_name:\n                grp_name, arg_name_base = arg_name.split(\":\", maxsplit=1)\n                if grp_name not in cls_attrs:\n                    raise ValueError(\n                        f\"invalid argument `{arg_name}`: \"\n                        f\"`{self.__class__}` has no group named `{grp_name}`\"\n                    )\n                if grp_name in d:\n                    raise ValueError(\n                        f\"conflicting arguments: `{arg_name}` and `{grp_name}`\"\n                    )\n                grp_type = cls_attrs[grp_name]\n                if not isinstance(grp_type, CorgyMeta):\n                    raise ValueError(f\"`{grp_name}` is not a `Corgy` class\")\n                main_args_map[grp_name][arg_name_base] = arg_val\n\n            elif arg_name in cls_attrs:\n                main_args_map[arg_name] = arg_val\n\n        for arg_name, arg_type in cls_attrs.items():\n            if arg_name not in main_args_map:\n                if strict and hasattr(self, arg_name):\n                    delattr(self, arg_name)\n                continue\n\n            arg_new_val = main_args_map[arg_name]\n            if isinstance(arg_type, CorgyMeta) and isinstance(arg_new_val, dict):\n                try:\n                    arg_obj = getattr(self, arg_name)\n                except AttributeError:\n                    setattr(self, arg_name, arg_type.from_dict(arg_new_val))\n                else:\n                    arg_obj.load_dict(arg_new_val, try_cast, strict)\n            else:\n                try:\n                    arg_new_val = check_val_type(\n                        arg_new_val,\n                        arg_type,\n                        try_cast,\n                        try_load_corgy_dicts=True,\n                        self_type=type(self),\n                    )\n                except ValueError as e:\n                    raise ValueError(f\"error setting `{arg_name}`: {e}\") from None\n                setattr(self, arg_name, arg_new_val)\n\n    @classmethod\n    def parse_from_cmdline(\n        cls: Type[_T],\n        parser: Optional[ArgumentParser] = None,\n        defaults: Optional[Mapping[str, Any]] = None,\n        **parser_args,\n    ) -&gt; _T:\n\"\"\"Return an instance of the class parsed from command line arguments.\n\n        Args:\n            parser: An instance of `argparse.ArgumentParser` or `None`. If `None`, a new\n                instance is created.\n            defaults: A dictionary of default values for the attributes, passed to\n                `add_args_to_parser`. Refer to the docs for `add_args_to_parser` for\n                more details.\n            parser_args: Arguments to be passed to `argparse.ArgumentParser()`. Ignored\n                if `parser` is not None.\n\n        Raises:\n            ArgumentTypeError: Error parsing command line arguments.\n        \"\"\"\n        if parser is None:\n            if \"formatter_class\" not in parser_args:\n                parser_args[\"formatter_class\"] = CorgyHelpFormatter\n            parser = ArgumentParser(**parser_args)\n        cls.add_args_to_parser(parser, defaults=defaults)\n        args = vars(parser.parse_args())\n        return cls.from_dict(args, try_cast=True)\n\n    @classmethod\n    def parse_from_toml(\n        cls: Type[_T],\n        toml_file: IO[bytes],\n        defaults: Optional[Mapping[str, Any]] = None,\n    ) -&gt; _T:\n\"\"\"Parse an object of the class from a toml file.\n\n        Args:\n            toml_file: A file-like object containing the class attributes in toml.\n            defaults: A dictionary of default values, overriding any values specified\n                in the class.\n\n        Raises:\n            TOMLDecodeError: Error parsing the toml file.\n\n        Example::\n\n            &gt;&gt;&gt; class G(Corgy):\n            ...     x: int\n            ...     y: Sequence[int]\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: str\n            ...     g: G\n\n            &gt;&gt;&gt; from io import BytesIO\n            &gt;&gt;&gt; f = BytesIO(b'''\n            ...     x = 'one'\n            ...     [g]\n            ...     x = 1\n            ...     y = [1, 2, 3]\n            ... ''')\n\n            &gt;&gt;&gt; A.parse_from_toml(f)  # doctest: +SKIP\n            A(x='one', g=G(x=1, y=[1, 2, 3]))\n\n        \"\"\"\n        tomli = import_module(\"tomllib\" if sys.version_info &gt;= (3, 11) else \"tomli\")\n        toml_data = tomli.load(toml_file)\n        if defaults is not None:\n            for _k, _v in defaults.items():\n                if _k not in toml_data:\n                    toml_data[_k] = _v\n        _parsers = getattr(cls, \"__parsers\")\n        for _k, _v in toml_data.items():\n            if _k in _parsers:\n                toml_data[_k] = _parsers[_k](_v)\n        return cls.from_dict(toml_data, try_cast=True)\n\n    def freeze(self):\n\"\"\"Freeze the object, preventing any further changes to attributes.\n\n        Example::\n\n            &gt;&gt;&gt; class A(Corgy):\n            ...     x: int\n            ...     y: int\n\n            &gt;&gt;&gt; a = A(x=1, y=2)\n            &gt;&gt;&gt; a.x = 2\n            &gt;&gt;&gt; a.freeze()\n            &gt;&gt;&gt; a.x = 3\n            Traceback (most recent call last):\n                ...\n            TypeError: cannot set `x`: object is frozen\n            &gt;&gt;&gt; del a.y\n            Traceback (most recent call last):\n                ...\n            TypeError: cannot delete `y`: object is frozen\n\n        \"\"\"\n        setattr(self, f\"_{self.__class__.__name__.lstrip('_')}__frozen\", True)\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.add_args_to_parser","title":"add_args_to_parser  <code>classmethod</code>","text":"<pre><code>add_args_to_parser(parser, name_prefix='', flatten_subgrps=False, defaults=None)\n</code></pre> <p>Add the class' <code>Corgy</code> attributes to the given parser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>_ActionsContainer</code> <p>Argument parser/group to which the attributes will be added.</p> required <code>name_prefix</code> <code>str</code> <p>Prefix for argument names. Arguments will be named <code>--&lt;name-prefix&gt;:&lt;attr-name&gt;</code>. If custom flags are present, <code>--&lt;name-prefix&gt;:&lt;flag&gt;</code> will be used instead (one for each flag).</p> <code>''</code> <code>flatten_subgrps</code> <code>bool</code> <p>Whether to add sub-groups to the main parser instead of creating argument groups. Note: sub-sub-groups are always added with this argument set to <code>True</code>, since <code>argparse</code> in unable to properly display nested group arguments.</p> <code>False</code> <code>defaults</code> <code>Optional[Mapping[str, Any]]</code> <p>Optional mapping with default values for arguments. Any value specified here will override default values specified in the class. Values for groups can be specified either as <code>Corgy</code> instances, or as individual values using the same syntax as for <code>Corgy.from_dict</code>.</p> <code>None</code> <p>Type annotations control how attributes are added to the parser. A number of special annotations are parsed and stripped from attribute types to determine the parameters for calling <code>ArgumentParser.add_argument</code>. These special annotations are described below.</p> <p>Note: <code>add_args_to_parser</code> cannot be used if the type annotation for any attribute of the class includes <code>Self</code>, unless a custom parser is defined for such attributes. See docs for <code>corgyparser</code> on how to define custom parsers.</p> <p>Annotated <code>typing.Annotated</code> can be used to add a help message for the argument::</p> <pre><code>&gt;&gt;&gt; import argparse\n&gt;&gt;&gt; from argparse import ArgumentParser\n&gt;&gt;&gt; from corgy import CorgyHelpFormatter\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Annotated[int, \"help for x\"]\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --x int  help for x (optional)\n</code></pre> <p>This annotation can also be used to modify the parser flags for the argument. By default, the attribute name is used, prefixed with <code>--</code>, and with <code>_</code> replaced by <code>-</code>. If the custom flag does not have a leading <code>-</code>, a positional argument will be created::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Annotated[int, \"help for x\", [\"-x\", \"--ex\"]]\n...     y: Annotated[int, \"help for y\", [\"y\"]]\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\npositional arguments:\n  y int        help for y\n&lt;BLANKLINE&gt;\noptions:\n  -x/--ex int  help for x (optional)\n</code></pre> <p><code>Annotated</code> can accept multiple arguments, but only the first three are used by <code>Corgy</code>. The first argument is the attribute type, the second is the help message (which must be a string), and the third is a sequence of flags.</p> <p>Required/NotRequired Every corgy attribute is either required or not required. The default status depends on the class parameter <code>corgy_required_by_default</code> (<code>False</code> by default). Attributes can also be explicitly marked as required or not required, and will control whether the argument will be added with <code>required=True</code>::</p> <pre><code>&gt;&gt;&gt; from corgy import Required, NotRequired\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Required[int]\n...     y: NotRequired[int]\n...     z: int\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --x int  (required)\n  --y int  (optional)\n  --z int  (optional)\n</code></pre> <p>Attributes which are not required, and don't have a default value are added with <code>default=argparse.SUPPRESS</code>, and so will not be in the parsed namespace::</p> <pre><code>&gt;&gt;&gt; parser.parse_args([\"--x\", \"1\", \"--y\", \"2\"])\nNamespace(x=1, y=2)\n</code></pre> <p>Optional Attributes marked with <code>typing.Optional</code> are allowed to be <code>None</code>. The arguments for these attributes can be passed with no values (i.e. <code>--x</code> instead of <code>--x=1</code> or <code>--x 1</code>) to indicate that the value should be <code>None</code>.</p> <p>Note: Attributes with default values are also \"optional\" in the sense that they can be omitted from the command line. However, they are not the same as attributes marked with <code>Optional</code>, since the former are not allowed to be <code>None</code>. Furthermore, <code>Required</code> <code>Optional</code> attributes without default values will need to be passed on the command line (possibly with no values).</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Required[Optional[int]]\n\n&gt;&gt;&gt; parser = ArgumentParser()\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.parse_args([\"--x\"])\nNamespace(x=None)\n</code></pre> <p>Boolean <code>bool</code> types (when not in a collection) are converted to a pair of options::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     arg: bool\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --arg/--no-arg\n</code></pre> <p>Collection Collection types are added to the parser by setting <code>nargs</code>. The value for <code>nargs</code> is determined by the collection type. Plain collections, such as <code>Sequence[int]</code>, will be added with <code>nargs=*</code>; Non-empty collections, such as <code>Sequence[int, ...]</code>, will be added with <code>nargs=+</code>; Finally, fixed-length collections, such as <code>Sequence[int, int, int]</code>, will be added with <code>nargs</code> set to the length of the collection.</p> <p>In all cases, collection types can only be added to a parser if they are single type. Heterogenous collections, such as <code>Sequence[int, str]</code> cannot be added, and will raise <code>ValueError</code>. Untyped collections (e.g., <code>x: Sequence</code>), also cannot be added.</p> <p>Arguments for optional collections will also accept no values to indicate <code>None</code>. Due to this, it is not possible to parse an empty collection for an optional collection argument::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Optional[Sequence[int]]\n...     y: Sequence[int]\n\n&gt;&gt;&gt; parser = ArgumentParser()\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.parse_args([\"--x\", \"--y\"])\nNamespace(x=None, y=[])\n</code></pre> <p>Literal For <code>Literal</code> types, the provided values are passed to the <code>choices</code> argument of <code>ArgumentParser.add_argument</code>. All values must be of the same type, which will be inferred from the type of the first value. If the first value has a <code>__bases__</code> attribute, the type will be inferred as the first base type, and all other choices must be subclasses of that type::</p> <pre><code>&gt;&gt;&gt; class T: ...\n&gt;&gt;&gt; class T1(T): ...\n&gt;&gt;&gt; class T2(T): ...\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Literal[T1, T2]\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --x T  ({T1/T2} optional)\n</code></pre> <p>For types which specify choices by defining <code>__choices__</code>, the values are passed to the <code>choices</code> argument as with <code>Literal</code>, but no type inference is performed, and the base attribute type will be used as the argument type.</p> <p>Single-value Literals A special case for <code>Literal</code> types is when there is only one choice. In this case, the argument is added as a <code>store_const</code> action, with the value as the <code>const</code> argument. A further special case is when the choice is <code>True/False</code>, in which case the action is <code>store_true</code>/<code>store_false</code> respectively::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Literal[True]\n...     y: Literal[False]\n...     z: Literal[42]\n\n&gt;&gt;&gt; parser = ArgumentParser()\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.parse_args([\"--x\"])  # Note that `y` and `z` are absent\nNamespace(x=True)\n&gt;&gt;&gt; parser.parse_args([\"--y\"])\nNamespace(y=False)\n&gt;&gt;&gt; parser.parse_args([\"--z\"])\nNamespace(z=42)\n</code></pre> <p>Note: This special case only applies to <code>Literal</code> types, and not types which define <code>__choices__</code>.</p> <p>Corgy Attributes which are themselves <code>Corgy</code> types are treated as argument groups. Group arguments are added to the command line parser with the group attribute name prefixed. Note that groups will ignore any custom flags when computing the prefix; elements within the group will use custom flags, but because they are prefixed with <code>--</code>, they will not be positional.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; class G(Corgy):\n...     x: int = 0\n...     y: float\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     g: G\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --x int      (optional)\n&lt;BLANKLINE&gt;\ng:\n  --g:x int    (default: 0)\n  --g:y float  (optional)\n</code></pre> <p>Custom parsers</p> <p>Attributes for which a custom parser is defined using <code>@corgyparser</code> will be added with a custom action that will call the parser. Refer to the documentation for <code>corgyparser</code> for details.</p> <p>Metavar</p> <p>This function will not explicitly pass a value for the <code>metavar</code> argument of <code>ArgumentParser.add_argument</code>, unless an attribute's type defines <code>__metavar__</code>, in which case, it will be passed as is. To change the metavar for attributes with custom parsers, set the <code>metavar</code> argument of <code>corgyparser</code>.</p> Source code in <code>corgy/_corgy.py</code> <pre><code>@classmethod\ndef add_args_to_parser(\n    cls,\n    parser: _ActionsContainer,\n    name_prefix: str = \"\",\n    flatten_subgrps: bool = False,\n    defaults: Optional[Mapping[str, Any]] = None,\n):\n\"\"\"Add the class' `Corgy` attributes to the given parser.\n\n    Args:\n        parser: Argument parser/group to which the attributes will be added.\n        name_prefix: Prefix for argument names. Arguments will be named\n            `--&lt;name-prefix&gt;:&lt;attr-name&gt;`. If custom flags are present,\n            `--&lt;name-prefix&gt;:&lt;flag&gt;` will be used instead (one for each flag).\n        flatten_subgrps: Whether to add sub-groups to the main parser instead of\n            creating argument groups. Note: sub-sub-groups are always added with\n            this argument set to `True`, since `argparse` in unable to properly\n            display nested group arguments.\n        defaults: Optional mapping with default values for arguments. Any value\n            specified here will override default values specified in the class.\n            Values for groups can be specified either as `Corgy` instances, or as\n            individual values using the same syntax as for `Corgy.from_dict`.\n\n    Type annotations control how attributes are added to the parser. A number of\n    special annotations are parsed and stripped from attribute types to determine\n    the parameters for calling `ArgumentParser.add_argument`. These special\n    annotations are described below.\n\n    Note: `add_args_to_parser` cannot be used if the type annotation for any\n    attribute of the class includes `Self`, unless a custom parser is defined\n    for such attributes. See docs for `corgyparser` on how to define custom\n    parsers.\n\n    *Annotated*\n    `typing.Annotated` can be used to add a help message for the argument::\n\n        &gt;&gt;&gt; import argparse\n        &gt;&gt;&gt; from argparse import ArgumentParser\n        &gt;&gt;&gt; from corgy import CorgyHelpFormatter\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Annotated[int, \"help for x\"]\n\n        &gt;&gt;&gt; parser = ArgumentParser(\n        ...     formatter_class=CorgyHelpFormatter,\n        ...     add_help=False,\n        ...     usage=argparse.SUPPRESS,\n        ... )\n\n        &gt;&gt;&gt; A.add_args_to_parser(parser)\n        &gt;&gt;&gt; parser.print_help()\n        options:\n          --x int  help for x (optional)\n\n    This annotation can also be used to modify the parser flags for the argument. By\n    default, the attribute name is used, prefixed with `--`, and with `_` replaced\n    by `-`. If the custom flag does not have a leading `-`, a positional argument\n    will be created::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Annotated[int, \"help for x\", [\"-x\", \"--ex\"]]\n        ...     y: Annotated[int, \"help for y\", [\"y\"]]\n\n        &gt;&gt;&gt; parser = ArgumentParser(\n        ...     formatter_class=CorgyHelpFormatter,\n        ...     add_help=False,\n        ...     usage=argparse.SUPPRESS,\n        ... )\n\n        &gt;&gt;&gt; A.add_args_to_parser(parser)\n        &gt;&gt;&gt; parser.print_help()\n        positional arguments:\n          y int        help for y\n        &lt;BLANKLINE&gt;\n        options:\n          -x/--ex int  help for x (optional)\n\n    `Annotated` can accept multiple arguments, but only the first three are used\n    by `Corgy`. The first argument is the attribute type, the second is the help\n    message (which must be a string), and the third is a sequence of flags.\n\n    *Required/NotRequired*\n    Every corgy attribute is either required or not required. The default status\n    depends on the class parameter `corgy_required_by_default` (`False` by default).\n    Attributes can also be explicitly marked as required or not required, and will\n    control whether the argument will be added with `required=True`::\n\n        &gt;&gt;&gt; from corgy import Required, NotRequired\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Required[int]\n        ...     y: NotRequired[int]\n        ...     z: int\n\n        &gt;&gt;&gt; parser = ArgumentParser(\n        ...     formatter_class=CorgyHelpFormatter,\n        ...     add_help=False,\n        ...     usage=argparse.SUPPRESS,\n        ... )\n\n        &gt;&gt;&gt; A.add_args_to_parser(parser)\n        &gt;&gt;&gt; parser.print_help()\n        options:\n          --x int  (required)\n          --y int  (optional)\n          --z int  (optional)\n\n    Attributes which are not required, and don't have a default value are added\n    with `default=argparse.SUPPRESS`, and so will not be in the parsed namespace::\n\n        &gt;&gt;&gt; parser.parse_args([\"--x\", \"1\", \"--y\", \"2\"])\n        Namespace(x=1, y=2)\n\n    *Optional*\n    Attributes marked with `typing.Optional` are allowed to be `None`. The\n    arguments for these attributes can be passed with no values (i.e. `--x`\n    instead of `--x=1` or `--x 1`) to indicate that the value should be `None`.\n\n    Note: Attributes with default values are also \"optional\" in the sense that\n    they can be omitted from the command line. However, they are not the same as\n    attributes marked with `Optional`, since the former are not allowed to be\n    `None`. Furthermore, `Required` `Optional` attributes without default values\n    _will_ need to be passed on the command line (possibly with no values).\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Required[Optional[int]]\n\n        &gt;&gt;&gt; parser = ArgumentParser()\n        &gt;&gt;&gt; A.add_args_to_parser(parser)\n        &gt;&gt;&gt; parser.parse_args([\"--x\"])\n        Namespace(x=None)\n\n    *Boolean*\n    `bool` types (when not in a collection) are converted to a pair of options::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     arg: bool\n\n        &gt;&gt;&gt; parser = ArgumentParser(\n        ...     formatter_class=CorgyHelpFormatter,\n        ...     add_help=False,\n        ...     usage=argparse.SUPPRESS,\n        ... )\n\n        &gt;&gt;&gt; A.add_args_to_parser(parser)\n        &gt;&gt;&gt; parser.print_help()\n        options:\n          --arg/--no-arg\n\n    *Collection*\n    Collection types are added to the parser by setting `nargs`. The value for\n    `nargs` is determined by the collection type. Plain collections, such as\n    `Sequence[int]`, will be added with `nargs=*`; Non-empty collections, such as\n    `Sequence[int, ...]`, will be added with `nargs=+`; Finally, fixed-length\n    collections, such as `Sequence[int, int, int]`, will be added with `nargs` set\n    to the length of the collection.\n\n    In all cases, collection types can only be added to a parser if they are single\n    type. Heterogenous collections, such as `Sequence[int, str]` cannot be added,\n    and will raise `ValueError`. Untyped collections (e.g., `x: Sequence`), also\n    cannot be added.\n\n    Arguments for optional collections will also accept no values to indicate\n    `None`. Due to this, it is not possible to parse an empty collection for\n    an optional collection argument::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Optional[Sequence[int]]\n        ...     y: Sequence[int]\n\n        &gt;&gt;&gt; parser = ArgumentParser()\n        &gt;&gt;&gt; A.add_args_to_parser(parser)\n        &gt;&gt;&gt; parser.parse_args([\"--x\", \"--y\"])\n        Namespace(x=None, y=[])\n\n    *Literal*\n    For `Literal` types, the provided values are passed to the `choices` argument\n    of `ArgumentParser.add_argument`. All values must be of the same type, which\n    will be inferred from the type of the first value. If the first value has a\n    `__bases__` attribute, the type will be inferred as the first base type, and\n    all other choices must be subclasses of that type::\n\n        &gt;&gt;&gt; class T: ...\n        &gt;&gt;&gt; class T1(T): ...\n        &gt;&gt;&gt; class T2(T): ...\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Literal[T1, T2]\n\n        &gt;&gt;&gt; parser = ArgumentParser(\n        ...     formatter_class=CorgyHelpFormatter,\n        ...     add_help=False,\n        ...     usage=argparse.SUPPRESS,\n        ... )\n\n        &gt;&gt;&gt; A.add_args_to_parser(parser)\n        &gt;&gt;&gt; parser.print_help()\n        options:\n          --x T  ({T1/T2} optional)\n\n    For types which specify choices by defining `__choices__`, the values are\n    passed to the `choices` argument as with `Literal`, but no type inference is\n    performed, and the base attribute type will be used as the argument type.\n\n    **Single-value Literals**\n    A special case for `Literal` types is when there is only one choice. In this\n    case, the argument is added as a `store_const` action, with the value as the\n    `const` argument. A further special case is when the choice is `True/False`,\n    in which case the action is `store_true`/`store_false` respectively::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Literal[True]\n        ...     y: Literal[False]\n        ...     z: Literal[42]\n\n        &gt;&gt;&gt; parser = ArgumentParser()\n        &gt;&gt;&gt; A.add_args_to_parser(parser)\n        &gt;&gt;&gt; parser.parse_args([\"--x\"])  # Note that `y` and `z` are absent\n        Namespace(x=True)\n        &gt;&gt;&gt; parser.parse_args([\"--y\"])\n        Namespace(y=False)\n        &gt;&gt;&gt; parser.parse_args([\"--z\"])\n        Namespace(z=42)\n\n    Note: This special case only applies to `Literal` types, and not types which\n    define `__choices__`.\n\n    *Corgy*\n    Attributes which are themselves `Corgy` types are treated as argument groups.\n    Group arguments are added to the command line parser with the group attribute\n    name prefixed. Note that groups will ignore any custom flags when computing the\n    prefix; elements within the group will use custom flags, but because they are\n    prefixed with `--`, they will not be positional.\n\n    Example::\n\n        &gt;&gt;&gt; class G(Corgy):\n        ...     x: int = 0\n        ...     y: float\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: int\n        ...     g: G\n\n        &gt;&gt;&gt; parser = ArgumentParser(\n        ...     formatter_class=CorgyHelpFormatter,\n        ...     add_help=False,\n        ...     usage=argparse.SUPPRESS,\n        ... )\n\n        &gt;&gt;&gt; A.add_args_to_parser(parser)\n        &gt;&gt;&gt; parser.print_help()\n        options:\n          --x int      (optional)\n        &lt;BLANKLINE&gt;\n        g:\n          --g:x int    (default: 0)\n          --g:y float  (optional)\n\n    **Custom parsers**\n\n    Attributes for which a custom parser is defined using `@corgyparser` will\n    be added with a custom action that will call the parser. Refer to the\n    documentation for `corgyparser` for details.\n\n    **Metavar**\n\n    This function will not explicitly pass a value for the `metavar` argument of\n    `ArgumentParser.add_argument`, unless an attribute's type defines `__metavar__`,\n    in which case, it will be passed as is. To change the metavar for attributes\n    with custom parsers, set the `metavar` argument of `corgyparser`.\n    \"\"\"\n    base_parser = parser\n    base_defaults = getattr(cls, \"__defaults\").copy()\n    if defaults is not None:\n        base_defaults.update(defaults)\n\n    # Extract default values for group arguments specified individually using\n    # the `&lt;group&gt;:&lt;var name&gt;` syntax.\n    group_arg_defaults: Dict[str, Dict[str, Any]] = defaultdict(dict)\n    for _k, _v in base_defaults.items():\n        if \":\" in _k:\n            _grp_name, _var_name = _k.split(\":\")\n            group_arg_defaults[_grp_name][_var_name] = _v\n        elif _k not in cls.__annotations__:\n            raise ValueError(f\"default value for unknown argument: `{_k}`\")\n\n    required_attrs = getattr(cls, \"__required\")\n    custom_flags = getattr(cls, \"__flags\")\n    custom_parsers = getattr(cls, \"__parsers\")\n\n    @dataclass\n    class _Arg:\n        name: str\n        required: Optional[bool] = None\n        positional: Optional[bool] = None\n        dest: Optional[str] = None\n        flags: Optional[Sequence[str]] = None\n        help: Optional[str] = None\n        nargs: Union[int, Literal[\"+\", \"*\"], None] = None\n        action: Optional[Type[argparse.Action]] = None\n        choices: Optional[Sequence[Any]] = None\n        metavar: Optional[str] = None\n        add_type: Optional[Any] = None\n        const: Optional[Any] = None\n\n        def get_add_kwargs(self) -&gt; Dict[str, Any]:\n            assert self.required is not None\n            assert self.positional is not None\n            assert self.dest is not None\n            kwargs: Dict[str, Any] = {}\n            if (not self.positional) and (self.name in custom_flags):\n                kwargs[\"dest\"] = self.dest\n            if self.help is not None:\n                kwargs[\"help\"] = self.help\n            if self.nargs is not None:\n                kwargs[\"nargs\"] = self.nargs\n            if self.action is not None:\n                kwargs[\"action\"] = self.action\n            if self.choices is not None:\n                kwargs[\"choices\"] = self.choices\n\n            if self.name in base_defaults:\n                kwargs[\"default\"] = base_defaults[self.name]\n            elif self.required and not self.positional:\n                kwargs[\"required\"] = True\n            elif not self.positional:\n                kwargs[\"default\"] = argparse.SUPPRESS\n\n            if self.metavar is not None:\n                kwargs[\"metavar\"] = self.metavar\n            if self.add_type is not None:\n                kwargs[\"type\"] = self.add_type\n            if self.const is not None:\n                kwargs[\"const\"] = self.const\n\n            return kwargs\n\n        def process_optional(self, type_) -&gt; Any:\n            if is_optional_type(type_):\n                self.action = OptionalTypeAction\n                return type_.__args__[0]\n            return type_\n\n        def process_collection(self, type_) -&gt; Any:\n            _col_type = get_concrete_collection_type(type_)\n            if _col_type is not None:\n                if (\n                    not hasattr(type_, \"__args__\")\n                    or not type_.__args__\n                    or isinstance(type_.__args__[0], TypeVar)\n                ):\n                    raise TypeError(\n                        f\"`{self.name}` is a collection, but has no type arguments:\"\n                        f\" use `{type_}[&lt;types&gt;]\"\n                    )\n                if len(type_.__args__) == 1:\n                    self.nargs = \"*\"\n                elif len(type_.__args__) == 2 and type_.__args__[1] is Ellipsis:\n                    # `...` is used to represent non-empty collections, e.g.,\n                    # `Sequence[int, ...]`.\n                    self.nargs = \"+\"\n                else:\n                    # Ensure single type.\n                    if any(_a != type_.__args__[0] for _a in type_.__args__[1:]):\n                        raise TypeError(\n                            f\"`{self.name}` has unsupported type `{type_}`: only\"\n                            f\" single-type collections are supported\"\n                        )\n                    self.nargs = len(type_.__args__)\n                return type_.__args__[0]\n            return type_\n\n        def process_choices(self, type_) -&gt; Any:\n            _is_literal_type = is_literal_type(type_)\n            if _is_literal_type:\n                # Determine if the first choice has `__bases__`, in which case\n                # the first base class is the type for the argument.\n                try:\n                    c0_type = type_.__args__[0].__bases__[0]\n                except AttributeError:\n                    c0_type = type(type_.__args__[0])\n                    f_check_type: Callable[[Any, Any], bool] = isinstance\n                else:\n                    f_check_type = issubclass\n\n                # All choices must be of the same type.\n                if any(not f_check_type(_a, c0_type) for _a in type_.__args__[1:]):\n                    raise TypeError(\n                        f\"choices for `{self.name}` not all of type `{c0_type}`: \"\n                        f\"`{type_.__args__}`\"\n                    )\n                self.choices = type_.__args__\n\n                # Convert single choice attributes to `store_*` actions.\n                if (\n                    self.choices is not None\n                    and len(self.choices) == 1\n                    and self.nargs is None\n                    and self.action is None\n                ):\n                    _choice = self.choices[0]\n                    if _choice is True:\n                        self.action = _StoreTrueAction\n                    elif _choice is False:\n                        self.action = _StoreFalseAction\n                    else:\n                        self.action = _StoreConstAction\n                        self.const = _choice\n                    self.choices = None\n                    return None\n                return c0_type\n\n            if hasattr(type_, \"__choices__\"):\n                self.choices = type_.__choices__\n\n            return type_\n\n    for var_name, var_type in cls.attrs().items():\n        var_arg = _Arg(var_name)\n        var_arg.help = getattr(\n            cls, var_name\n        ).__doc__  # doc is stored in the property\n        var_arg.required = (\n            var_name not in base_defaults and var_name in required_attrs\n        )\n\n        # Determine add flags.\n        var_arg.flags = custom_flags.get(\n            var_name, [f\"--{var_name.replace('_', '-')}\"]\n        )\n        assert var_arg.flags is not None\n        if name_prefix:\n            var_arg.flags = [\n                f\"--{name_prefix.replace('_', '-')}:{flag.lstrip('-')}\"\n                for flag in var_arg.flags\n            ]\n            var_arg.dest = f\"{name_prefix}:{var_name}\"\n        else:\n            var_arg.dest = var_name\n\n        # Determine if argument is positional.\n        if not any(_flag.startswith(\"-\") for _flag in var_arg.flags):\n            # Note: the flags cannot be passed to `add_argument` with `dest` set\n            # to `var_name` since `argparse` will raise an error for passing `dest`\n            # twice (for positional arguments, `argparse` uses the flag to infer the\n            # `dest`).\n            var_arg.flags = [var_name]\n            var_arg.positional = True\n        elif all(_flag.startswith(\"-\") for _flag in var_arg.flags):\n            var_arg.positional = False\n        else:\n            raise TypeError(\n                f\"inconsistent positional/optional flags for {var_name}: \"\n                f\"{var_arg.flags}\"\n            )\n\n        ###################################################################\n        # Check if the variable has a custom parser.\n        if var_name in custom_parsers:\n            _var_parser = custom_parsers[var_name]\n            _var_base_type = var_type\n            # Extract choices if present.\n            if is_literal_type(var_type):\n                _var_choices = var_type.__args__\n                try:\n                    _var_base_type = _var_choices[0].__bases__[0]\n                except AttributeError:\n                    _var_base_type = type(_var_choices[0])\n            elif hasattr(var_type, \"__choices__\"):\n                _var_choices = var_type.__choices__\n            else:\n                _var_choices = None\n\n            var_arg.action = partial(\n                CorgyParserAction, _var_parser, _var_choices  # type: ignore\n            )\n            var_arg.add_type = str\n            var_arg.nargs = getattr(_var_parser, \"__nargs__\", None)\n            try:\n                var_arg.metavar = _var_parser.__metavar__\n            except AttributeError:\n                try:\n                    var_arg.metavar = _var_base_type.__metavar__\n                except AttributeError:\n                    pass\n            parser.add_argument(*var_arg.flags, **var_arg.get_add_kwargs())\n            continue\n\n        ###################################################################\n        # Check if the variable is also `Corgy` type.\n        if type(var_type) is type(cls):\n            # Create an argument group using `&lt;var_type&gt;`.\n            # If there is a default value, pass it using `**defaults`.\n            if var_name in base_defaults:\n                try:\n                    grp_defaults = base_defaults[var_name].as_dict()\n                except AttributeError:\n                    raise ValueError(\n                        f\"default value for `{var_name}` is not a `Corgy` instance\"\n                    ) from None\n            else:\n                grp_defaults = {}\n\n            # Update defaults with any values specified individually.\n            grp_defaults.update(group_arg_defaults.get(var_name, {}))\n\n            grp_parser: _ActionsContainer\n            if flatten_subgrps:\n                grp_parser = base_parser\n            else:\n                grp_parser = base_parser.add_argument_group(\n                    var_arg.dest, var_arg.help\n                )\n            var_type.add_args_to_parser(\n                grp_parser, var_arg.dest, True, grp_defaults\n            )\n            continue\n\n        ###################################################################\n        # Check if the variable is boolean. Boolean variables are converted to\n        # `--&lt;var-name&gt;`/`--no-&lt;var-name&gt;` arguments (if not positional).\n        if var_type is bool:\n            var_arg.add_type = bool\n            if not var_arg.positional:\n                var_arg.action = BooleanOptionalAction\n            parser.add_argument(*var_arg.flags, **var_arg.get_add_kwargs())\n            continue\n\n        ###################################################################\n        # Process annotations.\n        var_base_type = var_type\n        var_base_type = var_arg.process_optional(var_base_type)\n        var_base_type = var_arg.process_collection(var_base_type)\n        var_base_type = var_arg.process_choices(var_base_type)\n\n        if var_base_type is Self:\n            raise TypeError(\n                \"'add_args_to_parser' cannot be used with 'Self' type present\"\n            )\n\n        var_arg.metavar = getattr(var_base_type, \"__metavar__\", None)\n        var_arg.add_type = var_base_type\n        parser.add_argument(*var_arg.flags, **var_arg.get_add_kwargs())\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.as_dict","title":"as_dict","text":"<pre><code>as_dict(recursive=True, flatten=False)\n</code></pre> <p>Return the object as a dictionary.</p> <p>The returned dictionary maps attribute names to their values. Unset attributes are omitted, unless they have default values.</p> <p>Parameters:</p> Name Type Description Default <code>recursive</code> <code>bool</code> <p>whether to recursively call <code>as_dict</code> on attributes which are <code>Corgy</code> instances. Otherwise, they are returned as is.</p> <code>True</code> <code>flatten</code> <code>bool</code> <p>whether to flatten group arguments into <code>:</code> separated strings. Only takes effect if <code>recursive</code> is <code>True</code>.</p> <code>False</code> <p>Examples::</p> <pre><code>&gt;&gt;&gt; class G(Corgy):\n...     x: int\n\n&gt;&gt;&gt; g = G(x=1)\n&gt;&gt;&gt; g.as_dict()\n{'x': 1}\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: str\n...     g: G\n\n&gt;&gt;&gt; a = A(x=\"one\", g=g)\n&gt;&gt;&gt; a.as_dict(recursive=False)\n{'x': 'one', 'g': G(x=1)}\n&gt;&gt;&gt; a.as_dict()\n{'x': 'one', 'g': {'x': 1}}\n&gt;&gt;&gt; a.as_dict(flatten=True)\n{'x': 'one', 'g:x': 1}\n</code></pre> Source code in <code>corgy/_corgy.py</code> <pre><code>def as_dict(self, recursive: bool = True, flatten: bool = False) -&gt; Dict[str, Any]:\n\"\"\"Return the object as a dictionary.\n\n    The returned dictionary maps attribute names to their values. Unset attributes\n    are omitted, unless they have default values.\n\n    Args:\n        recursive: whether to recursively call `as_dict` on attributes which are\n            `Corgy` instances. Otherwise, they are returned as is.\n        flatten: whether to flatten group arguments into `:` separated strings.\n            Only takes effect if `recursive` is `True`.\n\n    Examples::\n\n        &gt;&gt;&gt; class G(Corgy):\n        ...     x: int\n\n        &gt;&gt;&gt; g = G(x=1)\n        &gt;&gt;&gt; g.as_dict()\n        {'x': 1}\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: str\n        ...     g: G\n\n        &gt;&gt;&gt; a = A(x=\"one\", g=g)\n        &gt;&gt;&gt; a.as_dict(recursive=False)\n        {'x': 'one', 'g': G(x=1)}\n        &gt;&gt;&gt; a.as_dict()\n        {'x': 'one', 'g': {'x': 1}}\n        &gt;&gt;&gt; a.as_dict(flatten=True)\n        {'x': 'one', 'g:x': 1}\n\n    \"\"\"\n\n    def dictify_corgys(_val):\n        _coll_type = get_concrete_collection_type(type(_val))\n        if _coll_type is not None:\n            _cast_type = _coll_type if _coll_type is not AbstractSequence else list\n            return _cast_type(  # pylint: disable=abstract-class-instantiated\n                [dictify_corgys(_val_part) for _val_part in _val]\n            )\n        if isinstance(_val.__class__, CorgyMeta):\n            return _val.as_dict(recursive=True, flatten=flatten)\n        return _val\n\n    self_dict = {}\n    for attr_name, attr_type in self.attrs().items():\n        try:\n            attr_val = getattr(self, attr_name)\n        except AttributeError:\n            continue\n\n        if recursive:\n            attr_val = dictify_corgys(attr_val)\n            if flatten and (isinstance(attr_type, CorgyMeta) or attr_type is Self):\n                for _k, _v in attr_val.items():\n                    _flat_key = f\"{attr_name}:{_k}\"\n                    self_dict[_flat_key] = _v\n                continue\n\n        self_dict[attr_name] = attr_val\n\n    return self_dict\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.attrs","title":"attrs  <code>classmethod</code>","text":"<pre><code>attrs()\n</code></pre> <p>Return a dictionary mapping attributes of the class to their types.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Annotated[int, \"x\"]\n...     y: Sequence[str]\n\n&gt;&gt;&gt; A.attrs()\n{'x': &lt;class 'int'&gt;, 'y': typing.Sequence[str]}\n</code></pre> Source code in <code>corgy/_corgy.py</code> <pre><code>@classmethod\ndef attrs(cls) -&gt; Dict[str, Type]:\n\"\"\"Return a dictionary mapping attributes of the class to their types.\n\n    Example::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: Annotated[int, \"x\"]\n        ...     y: Sequence[str]\n\n        &gt;&gt;&gt; A.attrs()\n        {'x': &lt;class 'int'&gt;, 'y': typing.Sequence[str]}\n\n    \"\"\"\n    return {\n        _attr: getattr(cls, _attr).fget.__annotations__[\"return\"]\n        for _attr in cls.__annotations__\n    }\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.freeze","title":"freeze","text":"<pre><code>freeze()\n</code></pre> <p>Freeze the object, preventing any further changes to attributes.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: int\n\n&gt;&gt;&gt; a = A(x=1, y=2)\n&gt;&gt;&gt; a.x = 2\n&gt;&gt;&gt; a.freeze()\n&gt;&gt;&gt; a.x = 3\nTraceback (most recent call last):\n    ...\nTypeError: cannot set `x`: object is frozen\n&gt;&gt;&gt; del a.y\nTraceback (most recent call last):\n    ...\nTypeError: cannot delete `y`: object is frozen\n</code></pre> Source code in <code>corgy/_corgy.py</code> <pre><code>def freeze(self):\n\"\"\"Freeze the object, preventing any further changes to attributes.\n\n    Example::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: int\n        ...     y: int\n\n        &gt;&gt;&gt; a = A(x=1, y=2)\n        &gt;&gt;&gt; a.x = 2\n        &gt;&gt;&gt; a.freeze()\n        &gt;&gt;&gt; a.x = 3\n        Traceback (most recent call last):\n            ...\n        TypeError: cannot set `x`: object is frozen\n        &gt;&gt;&gt; del a.y\n        Traceback (most recent call last):\n            ...\n        TypeError: cannot delete `y`: object is frozen\n\n    \"\"\"\n    setattr(self, f\"_{self.__class__.__name__.lstrip('_')}__frozen\", True)\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d, try_cast=False)\n</code></pre> <p>Return a new instance of the class using a dictionary.</p> <p>This is roughly equivalent to <code>cls(**d)</code>, with the main exception being that groups can be specified as dictionaries themselves, and will be processed recursively.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Mapping[str, Any]</code> <p>Dictionary to create the instance from.</p> required <code>try_cast</code> <code>bool</code> <p>Whether to try and cast values which don't match attribute types.</p> <code>False</code> <p>Example::</p> <pre><code>&gt;&gt;&gt; class G(Corgy):\n...     x: int\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: str\n...     g: G\n\n&gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g\": G(x=1)})\nA(x='one', g=G(x=1))\n&gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g\": {\"x\": 1}})\nA(x='one', g=G(x=1))\n&gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g\": {\"x\": \"1\"}}, try_cast=True)\nA(x='one', g=G(x=1))\n&gt;&gt;&gt; G.from_dict({\"x\": \"1\"})\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n</code></pre> <p>Group attributes can also be passed directly in the dictionary by prefixing their names with the group name and a colon::</p> <pre><code>&gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g:x\": 1})\nA(x='one', g=G(x=1))\n\n&gt;&gt;&gt; class B(Corgy):\n...     x: float\n...     a: A\n\n&gt;&gt;&gt; B.from_dict({\"x\": 1.1, \"a:x\": \"one\", \"a:g:x\": 1})\nB(x=1.1, a=A(x='one', g=G(x=1)))\n</code></pre> Source code in <code>corgy/_corgy.py</code> <pre><code>@classmethod\ndef from_dict(cls: Type[_T], d: Mapping[str, Any], try_cast: bool = False) -&gt; _T:\n\"\"\"Return a new instance of the class using a dictionary.\n\n    This is roughly equivalent to `cls(**d)`, with the main exception being that\n    groups can be specified as dictionaries themselves, and will be processed\n    recursively.\n\n    Args:\n        d: Dictionary to create the instance from.\n        try_cast: Whether to try and cast values which don't match attribute types.\n\n    Example::\n\n        &gt;&gt;&gt; class G(Corgy):\n        ...     x: int\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: str\n        ...     g: G\n\n        &gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g\": G(x=1)})\n        A(x='one', g=G(x=1))\n        &gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g\": {\"x\": 1}})\n        A(x='one', g=G(x=1))\n        &gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g\": {\"x\": \"1\"}}, try_cast=True)\n        A(x='one', g=G(x=1))\n        &gt;&gt;&gt; G.from_dict({\"x\": \"1\"})\n        Traceback (most recent call last):\n            ...\n        ValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n\n    Group attributes can also be passed directly in the dictionary by prefixing\n    their names with the group name and a colon::\n\n        &gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g:x\": 1})\n        A(x='one', g=G(x=1))\n\n        &gt;&gt;&gt; class B(Corgy):\n        ...     x: float\n        ...     a: A\n\n        &gt;&gt;&gt; B.from_dict({\"x\": 1.1, \"a:x\": \"one\", \"a:g:x\": 1})\n        B(x=1.1, a=A(x='one', g=G(x=1)))\n\n    \"\"\"\n    main_args_map = {}\n    grp_args_map: Dict[str, Any] = defaultdict(dict)\n    cls_attrs = cls.attrs()\n\n    for arg_name, arg_val in d.items():\n        if \":\" in arg_name:\n            grp_name, arg_name_base = arg_name.split(\":\", maxsplit=1)\n            if not hasattr(cls, grp_name):\n                raise ValueError(\n                    f\"invalid argument `{arg_name}`: \"\n                    f\"`{cls}` has no group named `{grp_name}`\"\n                )\n            if grp_name in d:\n                raise ValueError(\n                    f\"conflicting arguments: `{arg_name}` and `{grp_name}`\"\n                )\n            grp_type = cls_attrs[grp_name]\n            if not isinstance(grp_type, CorgyMeta):\n                raise ValueError(f\"`{grp_name}` is not a `Corgy` class\")\n            grp_args_map[grp_name][arg_name_base] = arg_val\n\n        elif hasattr(cls, arg_name):\n            arg_type = cls_attrs[arg_name]\n            if isinstance(arg_type, CorgyMeta) and isinstance(arg_val, dict):\n                grp_args_map[arg_name] = arg_val\n            else:\n                main_args_map[arg_name] = arg_val\n\n    for grp_name, grp_args in grp_args_map.items():\n        grp_type = cls_attrs[grp_name]\n        main_args_map[grp_name] = grp_type.from_dict(grp_args, try_cast)\n\n    cls_attrs = cls.attrs()\n    for arg_name, arg_val in main_args_map.copy().items():\n        if arg_name in cls_attrs:\n            try:\n                main_args_map[arg_name] = check_val_type(\n                    arg_val,\n                    cls_attrs[arg_name],\n                    try_cast,\n                    try_load_corgy_dicts=True,\n                    self_type=cls,\n                )\n            except ValueError as e:\n                raise ValueError(f\"error setting `{arg_name}`: {e}\") from None\n    return cls(**main_args_map)\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.load_dict","title":"load_dict","text":"<pre><code>load_dict(d, try_cast=False, strict=False)\n</code></pre> <p>Load a dictionary into an instance of the class.</p> <p>Previous attributes are overwritten. Sub-dictionaries will be parsed recursively if the corresponding attribute already exists, else will be parsed using <code>from_dict</code>. As with <code>from_dict</code>, items in the dictionary without corresponding attributes are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Dict[str, Any]</code> <p>Dictionary to load.</p> required <code>try_cast</code> <code>bool</code> <p>Whether to try and cast values which don't match attribute types.</p> <code>False</code> <code>strict</code> <code>bool</code> <p>If <code>True</code>, attributes with existing values that are not in the dictionary will be unset.</p> <code>False</code> <p>Example::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: str\n&gt;&gt;&gt; a = A(x=1)\n&gt;&gt;&gt; _i = id(a)\n&gt;&gt;&gt; a.load_dict({\"y\": \"two\"})\n&gt;&gt;&gt; a\nA(x=1, y='two')\n&gt;&gt;&gt; _i == id(a)\nTrue\n&gt;&gt;&gt; a.load_dict({\"y\": \"three\"}, strict=True)\n&gt;&gt;&gt; a\nA(y='three')\n&gt;&gt;&gt; _i == id(a)\nTrue\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.load_dict({\"x\": \"1\"})\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n&gt;&gt;&gt; a.load_dict({\"x\": \"1\"}, try_cast=True)\n&gt;&gt;&gt; a\nA(x=1)\n</code></pre> Source code in <code>corgy/_corgy.py</code> <pre><code>def load_dict(\n    self, d: Dict[str, Any], try_cast: bool = False, strict: bool = False\n) -&gt; None:\n\"\"\"Load a dictionary into an instance of the class.\n\n    Previous attributes are overwritten. Sub-dictionaries will be parsed\n    recursively if the corresponding attribute already exists, else will be parsed\n    using `from_dict`. As with `from_dict`, items in the dictionary without\n    corresponding attributes are ignored.\n\n    Args:\n        d: Dictionary to load.\n        try_cast: Whether to try and cast values which don't match attribute types.\n        strict: If `True`, attributes with existing values that are not in the\n            dictionary will be unset.\n\n    Example::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: int\n        ...     y: str\n        &gt;&gt;&gt; a = A(x=1)\n        &gt;&gt;&gt; _i = id(a)\n        &gt;&gt;&gt; a.load_dict({\"y\": \"two\"})\n        &gt;&gt;&gt; a\n        A(x=1, y='two')\n        &gt;&gt;&gt; _i == id(a)\n        True\n        &gt;&gt;&gt; a.load_dict({\"y\": \"three\"}, strict=True)\n        &gt;&gt;&gt; a\n        A(y='three')\n        &gt;&gt;&gt; _i == id(a)\n        True\n        &gt;&gt;&gt; a = A()\n        &gt;&gt;&gt; a.load_dict({\"x\": \"1\"})\n        Traceback (most recent call last):\n            ...\n        ValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n        &gt;&gt;&gt; a.load_dict({\"x\": \"1\"}, try_cast=True)\n        &gt;&gt;&gt; a\n        A(x=1)\n\n    \"\"\"\n    main_args_map: Dict[str, Any] = defaultdict(dict)\n    cls_attrs = self.attrs()\n\n    for arg_name, arg_val in d.items():\n        if \":\" in arg_name:\n            grp_name, arg_name_base = arg_name.split(\":\", maxsplit=1)\n            if grp_name not in cls_attrs:\n                raise ValueError(\n                    f\"invalid argument `{arg_name}`: \"\n                    f\"`{self.__class__}` has no group named `{grp_name}`\"\n                )\n            if grp_name in d:\n                raise ValueError(\n                    f\"conflicting arguments: `{arg_name}` and `{grp_name}`\"\n                )\n            grp_type = cls_attrs[grp_name]\n            if not isinstance(grp_type, CorgyMeta):\n                raise ValueError(f\"`{grp_name}` is not a `Corgy` class\")\n            main_args_map[grp_name][arg_name_base] = arg_val\n\n        elif arg_name in cls_attrs:\n            main_args_map[arg_name] = arg_val\n\n    for arg_name, arg_type in cls_attrs.items():\n        if arg_name not in main_args_map:\n            if strict and hasattr(self, arg_name):\n                delattr(self, arg_name)\n            continue\n\n        arg_new_val = main_args_map[arg_name]\n        if isinstance(arg_type, CorgyMeta) and isinstance(arg_new_val, dict):\n            try:\n                arg_obj = getattr(self, arg_name)\n            except AttributeError:\n                setattr(self, arg_name, arg_type.from_dict(arg_new_val))\n            else:\n                arg_obj.load_dict(arg_new_val, try_cast, strict)\n        else:\n            try:\n                arg_new_val = check_val_type(\n                    arg_new_val,\n                    arg_type,\n                    try_cast,\n                    try_load_corgy_dicts=True,\n                    self_type=type(self),\n                )\n            except ValueError as e:\n                raise ValueError(f\"error setting `{arg_name}`: {e}\") from None\n            setattr(self, arg_name, arg_new_val)\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.parse_from_cmdline","title":"parse_from_cmdline  <code>classmethod</code>","text":"<pre><code>parse_from_cmdline(parser=None, defaults=None, **parser_args)\n</code></pre> <p>Return an instance of the class parsed from command line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>Optional[ArgumentParser]</code> <p>An instance of <code>argparse.ArgumentParser</code> or <code>None</code>. If <code>None</code>, a new instance is created.</p> <code>None</code> <code>defaults</code> <code>Optional[Mapping[str, Any]]</code> <p>A dictionary of default values for the attributes, passed to <code>add_args_to_parser</code>. Refer to the docs for <code>add_args_to_parser</code> for more details.</p> <code>None</code> <code>parser_args</code> <p>Arguments to be passed to <code>argparse.ArgumentParser()</code>. Ignored if <code>parser</code> is not None.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>Error parsing command line arguments.</p> Source code in <code>corgy/_corgy.py</code> <pre><code>@classmethod\ndef parse_from_cmdline(\n    cls: Type[_T],\n    parser: Optional[ArgumentParser] = None,\n    defaults: Optional[Mapping[str, Any]] = None,\n    **parser_args,\n) -&gt; _T:\n\"\"\"Return an instance of the class parsed from command line arguments.\n\n    Args:\n        parser: An instance of `argparse.ArgumentParser` or `None`. If `None`, a new\n            instance is created.\n        defaults: A dictionary of default values for the attributes, passed to\n            `add_args_to_parser`. Refer to the docs for `add_args_to_parser` for\n            more details.\n        parser_args: Arguments to be passed to `argparse.ArgumentParser()`. Ignored\n            if `parser` is not None.\n\n    Raises:\n        ArgumentTypeError: Error parsing command line arguments.\n    \"\"\"\n    if parser is None:\n        if \"formatter_class\" not in parser_args:\n            parser_args[\"formatter_class\"] = CorgyHelpFormatter\n        parser = ArgumentParser(**parser_args)\n    cls.add_args_to_parser(parser, defaults=defaults)\n    args = vars(parser.parse_args())\n    return cls.from_dict(args, try_cast=True)\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.parse_from_toml","title":"parse_from_toml  <code>classmethod</code>","text":"<pre><code>parse_from_toml(toml_file, defaults=None)\n</code></pre> <p>Parse an object of the class from a toml file.</p> <p>Parameters:</p> Name Type Description Default <code>toml_file</code> <code>IO[bytes]</code> <p>A file-like object containing the class attributes in toml.</p> required <code>defaults</code> <code>Optional[Mapping[str, Any]]</code> <p>A dictionary of default values, overriding any values specified in the class.</p> <code>None</code> <p>Raises:</p> Type Description <code>TOMLDecodeError</code> <p>Error parsing the toml file.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; class G(Corgy):\n...     x: int\n...     y: Sequence[int]\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: str\n...     g: G\n\n&gt;&gt;&gt; from io import BytesIO\n&gt;&gt;&gt; f = BytesIO(b'''\n...     x = 'one'\n...     [g]\n...     x = 1\n...     y = [1, 2, 3]\n... ''')\n\n&gt;&gt;&gt; A.parse_from_toml(f)  # doctest: +SKIP\nA(x='one', g=G(x=1, y=[1, 2, 3]))\n</code></pre> Source code in <code>corgy/_corgy.py</code> <pre><code>@classmethod\ndef parse_from_toml(\n    cls: Type[_T],\n    toml_file: IO[bytes],\n    defaults: Optional[Mapping[str, Any]] = None,\n) -&gt; _T:\n\"\"\"Parse an object of the class from a toml file.\n\n    Args:\n        toml_file: A file-like object containing the class attributes in toml.\n        defaults: A dictionary of default values, overriding any values specified\n            in the class.\n\n    Raises:\n        TOMLDecodeError: Error parsing the toml file.\n\n    Example::\n\n        &gt;&gt;&gt; class G(Corgy):\n        ...     x: int\n        ...     y: Sequence[int]\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: str\n        ...     g: G\n\n        &gt;&gt;&gt; from io import BytesIO\n        &gt;&gt;&gt; f = BytesIO(b'''\n        ...     x = 'one'\n        ...     [g]\n        ...     x = 1\n        ...     y = [1, 2, 3]\n        ... ''')\n\n        &gt;&gt;&gt; A.parse_from_toml(f)  # doctest: +SKIP\n        A(x='one', g=G(x=1, y=[1, 2, 3]))\n\n    \"\"\"\n    tomli = import_module(\"tomllib\" if sys.version_info &gt;= (3, 11) else \"tomli\")\n    toml_data = tomli.load(toml_file)\n    if defaults is not None:\n        for _k, _v in defaults.items():\n            if _k not in toml_data:\n                toml_data[_k] = _v\n    _parsers = getattr(cls, \"__parsers\")\n    for _k, _v in toml_data.items():\n        if _k in _parsers:\n            toml_data[_k] = _parsers[_k](_v)\n    return cls.from_dict(toml_data, try_cast=True)\n</code></pre>"},{"location":"usage/corgy.html#corgy.corgyparser","title":"corgy.corgyparser","text":"<pre><code>corgy.corgyparser(*var_names, metavar=None, nargs=None)\n</code></pre> <p>Decorate a function as a custom parser for one or more attributes.</p> <p>To use a custom function for parsing a <code>Corgy</code> attribute, use this decorator. Parsing functions must be static, and should only accept a single argument. Decorating the function with <code>@staticmethod</code> is optional, but prevents type errors. <code>@corgyparser</code> must be the final decorator in the decorator chain.</p> <p>Parameters:</p> Name Type Description Default <code>var_names</code> <code>str</code> <p>The attributes associated with the decorated parser.</p> <code>()</code> <code>metavar</code> <code>Optional[str]</code> <p>Keyword only argument to set the metavar when adding the associated attribute(s) to an <code>ArgumentParser</code> instance.</p> <code>None</code> <code>nargs</code> <code>Union[None, Literal['*', '+'], int]</code> <p>Keyword only argument to set the number of arguments to be used for the associated attribute(s). Must be <code>None</code>, <code>'*'</code>, <code>'+'</code>, or a positive number. This value is passed as the <code>nargs</code> argument to <code>ArgumentParser.add_argument</code>, and controls the number of arguments that will be read from the command line, and passed to the parsing function. For all values other than <code>None</code>, the parsing function will receive a list of strings.</p> <code>None</code> <p>Example::</p> <pre><code>&gt;&gt;&gt; import argparse\n&gt;&gt;&gt; from argparse import ArgumentParser\n&gt;&gt;&gt; from typing import Tuple\n&gt;&gt;&gt; from corgy import Corgy, CorgyHelpFormatter, corgyparser\n\n&gt;&gt;&gt; class A(Corgy):\n...     time: Tuple[int, int, int]\n...     @corgyparser(\"time\", metavar=\"int:int:int\")\n...     @staticmethod\n...     def parse_time(s):\n...         return tuple(map(int, s.split(\":\")))\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.parse_args([\"--time\", \"1:2:3\"])\nNamespace(time=(1, 2, 3))\n</code></pre> <p>Multiple arguments can be passed to the decorator, and will all be associated with the same parser::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: int\n...     @corgyparser(\"x\", \"y\")\n...     @staticmethod\n...     def parse_x_y(s):\n...         return int(s)\n</code></pre> <p>The <code>@corgyparser</code> decorator can also be chained to use the same parser for multiple arguments::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: int\n...     @corgyparser(\"x\")\n...     @corgyparser(\"y\")\n...     @staticmethod\n...     def parse_x_y(s):\n...         return int(s)\n</code></pre> <p>Note: when chaining, the outer-most non-<code>None</code> value of <code>metavar</code> will be used.</p> <p>Custom parsers can control the number of arguments they receive, independent of the argument type::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     @corgyparser(\"x\", nargs=3)\n...     @staticmethod\n...     def parse_x(s):\n...         # `s` will be a list of 3 strings.\n...         return sum(map(int, s))\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.parse_args([\"--x\", \"1\", \"2\", \"3\"])\nNamespace(x=6)\n</code></pre> <p>When chaining, <code>nargs</code> must be the same for all decorators, otherwise <code>TypeError</code> is raised.</p> Source code in <code>corgy/_corgyparser.py</code> <pre><code>def corgyparser(\n    *var_names: str,\n    metavar: Optional[str] = None,\n    nargs: Union[None, Literal[\"*\", \"+\"], int] = None,\n) -&gt; Callable[[Union[Callable[[str], Any], CorgyParser]], CorgyParser]:\n\"\"\"Decorate a function as a custom parser for one or more attributes.\n\n    To use a custom function for parsing a `Corgy` attribute, use this decorator.\n    Parsing functions must be static, and should only accept a single argument.\n    Decorating the function with `@staticmethod` is optional, but prevents type errors.\n    `@corgyparser` must be the final decorator in the decorator chain.\n\n    Args:\n        var_names: The attributes associated with the decorated parser.\n        metavar: Keyword only argument to set the metavar when adding the associated\n            attribute(s) to an `ArgumentParser` instance.\n        nargs: Keyword only argument to set the number of arguments to be used for the\n            associated attribute(s). Must be `None`, `'*'`, `'+'`, or a positive number.\n            This value is passed as the `nargs` argument to\n            `ArgumentParser.add_argument`, and controls the number of arguments that\n            will be read from the command line, and passed to the parsing function.\n            For all values other than `None`, the parsing function will receive a list\n            of strings.\n\n    Example::\n\n        &gt;&gt;&gt; import argparse\n        &gt;&gt;&gt; from argparse import ArgumentParser\n        &gt;&gt;&gt; from typing import Tuple\n        &gt;&gt;&gt; from corgy import Corgy, CorgyHelpFormatter, corgyparser\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     time: Tuple[int, int, int]\n        ...     @corgyparser(\"time\", metavar=\"int:int:int\")\n        ...     @staticmethod\n        ...     def parse_time(s):\n        ...         return tuple(map(int, s.split(\":\")))\n\n        &gt;&gt;&gt; parser = ArgumentParser(\n        ...     formatter_class=CorgyHelpFormatter,\n        ...     add_help=False,\n        ...     usage=argparse.SUPPRESS,\n        ... )\n\n        &gt;&gt;&gt; A.add_args_to_parser(parser)\n        &gt;&gt;&gt; parser.parse_args([\"--time\", \"1:2:3\"])\n        Namespace(time=(1, 2, 3))\n\n    Multiple arguments can be passed to the decorator, and will all be associated with\n    the same parser::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: int\n        ...     y: int\n        ...     @corgyparser(\"x\", \"y\")\n        ...     @staticmethod\n        ...     def parse_x_y(s):\n        ...         return int(s)\n\n    The `@corgyparser` decorator can also be chained to use the same parser for multiple\n    arguments::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: int\n        ...     y: int\n        ...     @corgyparser(\"x\")\n        ...     @corgyparser(\"y\")\n        ...     @staticmethod\n        ...     def parse_x_y(s):\n        ...         return int(s)\n\n    Note: when chaining, the outer-most non-`None` value of `metavar` will be used.\n\n    Custom parsers can control the number of arguments they receive, independent of the\n    argument type::\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: int\n        ...     @corgyparser(\"x\", nargs=3)\n        ...     @staticmethod\n        ...     def parse_x(s):\n        ...         # `s` will be a list of 3 strings.\n        ...         return sum(map(int, s))\n\n        &gt;&gt;&gt; parser = ArgumentParser(\n        ...     formatter_class=CorgyHelpFormatter,\n        ...     add_help=False,\n        ...     usage=argparse.SUPPRESS,\n        ... )\n\n        &gt;&gt;&gt; A.add_args_to_parser(parser)\n        &gt;&gt;&gt; parser.parse_args([\"--x\", \"1\", \"2\", \"3\"])\n        Namespace(x=6)\n\n    When chaining, `nargs` must be the same for all decorators, otherwise `TypeError` is\n    raised.\n    \"\"\"\n    if not all(isinstance(_var_name, str) for _var_name in var_names):\n        raise TypeError(\n            \"corgyparser should be passed the name of arguments: decorate using\"\n            \"@corgyparser(&lt;argument(s)&gt;)\"\n        )\n\n    def wrapper(var_names, metavar, fparse):\n        if isinstance(fparse, CorgyParser):\n            if nargs != fparse.nargs:\n                raise TypeError(\n                    \"all `corgyparser` decorations of a funciton must have same `nargs`\"\n                )\n            corgy_parser = fparse\n            corgy_parser.var_names.extend(var_names)\n        else:\n            if isinstance(fparse, staticmethod):\n                fparse = fparse.__func__\n            if not callable(fparse):\n                raise TypeError(\"corgyparser can only decorate static functions\")\n            corgy_parser = CorgyParser(list(var_names), fparse, nargs)\n\n        if metavar is not None:\n            setattr(corgy_parser.fparse, \"__metavar__\", metavar)\n        if nargs is not None:\n            setattr(corgy_parser.fparse, \"__nargs__\", nargs)\n        return corgy_parser\n\n    return partial(wrapper, var_names, metavar)\n</code></pre>"},{"location":"usage/corgy.html#corgy.corgychecker","title":"corgy.corgychecker","text":"<pre><code>corgy.corgychecker(*var_names)\n</code></pre> <p>Decorate a function as a custom checker for one or more attributes.</p> <p>To use a custom function for checking the value of a <code>Corgy</code> attribute, use this decorator. Checking functions must be static, and should only accept a single argument, the value to be checked. They should raise <code>ValueError</code> to indicate value mismatch. Decorating the function with <code>@staticmethod</code> is optional, but prevents type errors. <code>@corgychecker</code> must be the final decorator in the decorator chain.</p> <p>Custom checkers are called after type checking, so the values passed to them will be of type corresponding to one of the assigned attributes.</p> <p>Parameters:</p> Name Type Description Default <code>var_names</code> <code>str</code> <p>The attributes associated with the decorated checker.</p> <code>()</code> <p>Example::</p> <pre><code>&gt;&gt;&gt; from corgy import Corgy, corgychecker\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     @corgychecker(\"x\")\n...     @staticmethod\n...     def check_x(val):\n...         if val % 2:\n...             raise ValueError(f\"'{val}' is not even\")\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = 2\n&gt;&gt;&gt; a.x = 3\nTraceback (most recent call last):\n   ...\nValueError: error setting `x`: '3' is not even\n</code></pre> <p>Multiple attributes can use the same checker, either by chaining <code>corgychecker</code>, or by passing all attribute names directly::</p> <pre><code>&gt;&gt;&gt; from typing import Sequence\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: float\n...     z: str\n...     w: Sequence[int]\n...     @corgychecker(\"x\")\n...     @corgychecker(\"y\")\n...     def check_num(val):\n...         if val &lt; 0:\n...             raise ValueError(\"should be non-negative\")\n...     @corgychecker(\"z\", \"w\")\n...     def check_seq(val):\n...         if len(val) &gt; 10:\n...             raise ValueError(\"too long\")\n</code></pre> Source code in <code>corgy/_corgychecker.py</code> <pre><code>def corgychecker(\n    *var_names: str,\n) -&gt; Callable[[Union[Callable, CorgyChecker]], CorgyChecker]:\n\"\"\"Decorate a function as a custom checker for one or more attributes.\n\n    To use a custom function for checking the value of a `Corgy` attribute, use this\n    decorator. Checking functions must be static, and should only accept a single\n    argument, the value to be checked. They should raise `ValueError` to indicate value\n    mismatch. Decorating the function with `@staticmethod` is optional, but prevents\n    type errors. `@corgychecker` must be the final decorator in the decorator chain.\n\n    Custom checkers are called _after_ type checking, so the values passed to them will\n    be of type corresponding to one of the assigned attributes.\n\n    Args:\n        var_names: The attributes associated with the decorated checker.\n\n    Example::\n\n        &gt;&gt;&gt; from corgy import Corgy, corgychecker\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: int\n        ...     @corgychecker(\"x\")\n        ...     @staticmethod\n        ...     def check_x(val):\n        ...         if val % 2:\n        ...             raise ValueError(f\"'{val}' is not even\")\n\n        &gt;&gt;&gt; a = A()\n        &gt;&gt;&gt; a.x = 2\n        &gt;&gt;&gt; a.x = 3\n        Traceback (most recent call last):\n           ...\n        ValueError: error setting `x`: '3' is not even\n\n    Multiple attributes can use the same checker, either by chaining `corgychecker`, or\n    by passing all attribute names directly::\n\n        &gt;&gt;&gt; from typing import Sequence\n\n        &gt;&gt;&gt; class A(Corgy):\n        ...     x: int\n        ...     y: float\n        ...     z: str\n        ...     w: Sequence[int]\n        ...     @corgychecker(\"x\")\n        ...     @corgychecker(\"y\")\n        ...     def check_num(val):\n        ...         if val &lt; 0:\n        ...             raise ValueError(\"should be non-negative\")\n        ...     @corgychecker(\"z\", \"w\")\n        ...     def check_seq(val):\n        ...         if len(val) &gt; 10:\n        ...             raise ValueError(\"too long\")\n\n    \"\"\"\n    if not all(isinstance(_var_name, str) for _var_name in var_names):\n        raise TypeError(\n            \"corgychecker should be passed the name of arguments: decorate using\"\n            \"@corgychecker(&lt;argument(s)&gt;)\"\n        )\n\n    def wrapper(var_names, fcheck):\n        if isinstance(fcheck, CorgyChecker):\n            corgy_checker = fcheck\n            corgy_checker.var_names.extend(var_names)\n        else:\n            if isinstance(fcheck, staticmethod):\n                fcheck = fcheck.__func__\n            if not callable(fcheck):\n                raise TypeError(\"corgychecker can only decorate static functions\")\n            corgy_checker = CorgyChecker(list(var_names), fcheck)\n        return corgy_checker\n\n    return partial(wrapper, var_names)\n</code></pre>"},{"location":"usage/corgy.types.html","title":"corgy.types","text":"<p>Types for use with <code>corgy</code> (or standalone with <code>argparse</code>).</p> <p>An object of the types defined in this module can be created by calling the respective type class with a single string argument. <code>ValueError</code> is raised if the argument can not be converted to the desired type.</p> <p>Examples::</p> <pre><code>&gt;&gt;&gt; from corgy.types import KeyValuePairs\n&gt;&gt;&gt; StrIntMapType = KeyValuePairs[str, int]\n&gt;&gt;&gt; str_int_map = StrIntMapType(\"a=1,b=2\")\n&gt;&gt;&gt; print(str_int_map)\n{'a': 1, 'b': 2}\n\n&gt;&gt;&gt; class A: ...\n&gt;&gt;&gt; class B(A): ...\n&gt;&gt;&gt; class C(A): ...\n\n&gt;&gt;&gt; from corgy.types import SubClass\n&gt;&gt;&gt; ASubClsType = SubClass[A]\n&gt;&gt;&gt; a_subcls = ASubClsType(\"B\")\n&gt;&gt;&gt; a_subcls_obj = a_subcls()\n&gt;&gt;&gt; a_subcls_obj  # doctest: +SKIP\n&lt;B object at 0x106cd93d0&gt;\n\n&gt;&gt;&gt; import argparse\n&gt;&gt;&gt; from argparse import ArgumentParser\n&gt;&gt;&gt; from corgy import CorgyHelpFormatter\n&gt;&gt;&gt; from corgy.types import InputFile\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n&gt;&gt;&gt; _ = parser.add_argument(\"--f\", type=InputFile)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --f file  (default: None)\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types.KeyValuePairs","title":"corgy.types.KeyValuePairs","text":"<p>         Bases: <code>dict</code>, <code>Generic[_KT, _VT]</code></p> <p>Dictionary sub-class that is initialized from a string of key-value pairs.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; from corgy.types import KeyValuePairs\n\n&gt;&gt;&gt; MapType = KeyValuePairs[str, int]\n&gt;&gt;&gt; print(MapType(\"a=1,b=2\"))\n{'a': 1, 'b': 2}\n</code></pre> <p>This class supports the class indexing syntax to specify the types for keys and values. <code>KeyValuePairs[KT, VT]</code> returns a new <code>KeyValuePairs</code> type where the key and value types are <code>KT</code> and <code>VT</code>, respectively. Using the class directly is equivalent to using <code>KeyValuePairs[str, str]</code>.</p> <p>When called, the class expects a single string argument, with comma-separated <code>key=value</code> pairs (see below for how to change the separators). The string is parsed, and a dictionary is created with the keys and values cast to their respective types. <code>ValueError</code> is raised if this fails. This class is useful for parsing dictionaries from command-line arguments.</p> <p>By default, the class expects a string of the form <code>key1=value1,key2=value2,...</code>. This can be changed by setting the following class attributes:</p> <ul> <li> <p>sequence_separator: The string that separates individual key-value pairs. The     default is <code>,</code>.</p> </li> <li> <p>item_separator: The string that separates keys and values. The default is <code>=</code>.</p> </li> </ul> <p>Note that types returned by the <code>KeyValuePairs[...]</code> syntax are cached using the key and value types::</p> <pre><code>&gt;&gt;&gt; MapType = KeyValuePairs[str, int]\n&gt;&gt;&gt; MapType.sequence_separator = \";\"\n&gt;&gt;&gt; MapType2 = KeyValuePairs[str, int]  # same as `MapType`\n&gt;&gt;&gt; MapType2.sequence_separator\n';'\n&gt;&gt;&gt; MapType2.sequence_separator = \",\"\n</code></pre> <p><code>KeyValuePairs</code> instances can also be initialized with a dictionary. However, note that the dictionary is not type-checked and is used as-is.</p> Source code in <code>corgy/types/_keyvaluepairs.py</code> <pre><code>class KeyValuePairs(  # type: ignore[misc]\n    dict, Generic[_KT, _VT], metaclass=_KeyValuePairsMeta\n):\n\"\"\"Dictionary sub-class that is initialized from a string of key-value pairs.\n\n    Example::\n\n        &gt;&gt;&gt; from corgy.types import KeyValuePairs\n\n        &gt;&gt;&gt; MapType = KeyValuePairs[str, int]\n        &gt;&gt;&gt; print(MapType(\"a=1,b=2\"))\n        {'a': 1, 'b': 2}\n\n    This class supports the class indexing syntax to specify the types for keys and\n    values. `KeyValuePairs[KT, VT]` returns a new `KeyValuePairs` type where the key\n    and value types are `KT` and `VT`, respectively. Using the class directly is\n    equivalent to using `KeyValuePairs[str, str]`.\n\n    When called, the class expects a single string argument, with comma-separated\n    `key=value` pairs (see below for how to change the separators). The string is\n    parsed, and a dictionary is created with the keys and values cast to their\n    respective types. `ValueError` is raised if this fails. This class is\n    useful for parsing dictionaries from command-line arguments.\n\n    By default, the class expects a string of the form `key1=value1,key2=value2,...`.\n    This can be changed by setting the following class attributes:\n\n    * sequence_separator: The string that separates individual key-value pairs. The\n        default is `,`.\n\n    * item_separator: The string that separates keys and values. The default is `=`.\n\n    Note that types returned by the `KeyValuePairs[...]` syntax are cached using the\n    key and value types::\n\n        &gt;&gt;&gt; MapType = KeyValuePairs[str, int]\n        &gt;&gt;&gt; MapType.sequence_separator = \";\"\n        &gt;&gt;&gt; MapType2 = KeyValuePairs[str, int]  # same as `MapType`\n        &gt;&gt;&gt; MapType2.sequence_separator\n        ';'\n        &gt;&gt;&gt; MapType2.sequence_separator = \",\"\n\n    `KeyValuePairs` instances can also be initialized with a dictionary. However, note\n    that the dictionary is not type-checked and is used as-is.\n    \"\"\"\n\n    sequence_separator: str = \",\"\n    item_separator: str = \"=\"\n\n    _kt: Type[_KT]\n    _vt: Type[_VT]\n    _type_cache: Dict[Tuple[Type[_KT], Type[_VT]], Type[KeyValuePairs[_KT, _VT]]] = {}\n\n    __slots__ = (\"_src\",)\n\n    def __class_getitem__(  # type: ignore\n        cls, item: Tuple[Type[_KT], Type[_VT]]\n    ) -&gt; Type[KeyValuePairs[_KT, _VT]]:\n        if hasattr(cls, \"_kt\"):\n            raise TypeError(\n                f\"cannot further sub-script \"\n                f\"`{cls.__name__}[{cls._kt.__name__}, {cls._vt.__name__}]`\"\n            )\n\n        try:\n            ret_type = cls._type_cache[item]\n        except (KeyError, TypeError) as e:\n            kt, vt = item\n            ret_type = type(\n                f\"{cls.__name__}[{kt.__name__},{vt.__name__}]\",\n                (cls,),\n                {\n                    \"_kt\": kt,\n                    \"_vt\": vt,\n                    \"sequence_separator\": cls.sequence_separator,\n                    \"item_separator\": cls.item_separator,\n                    \"__slots__\": cls.__slots__,\n                },\n            )\n            if not isinstance(e, TypeError):\n                # `TypeError` is raised if the item is not hashable.\n                cls._type_cache[item] = ret_type\n            sys.modules[ret_type.__module__].__dict__[ret_type.__name__] = ret_type\n        return ret_type\n\n    @classmethod  # type: ignore\n    @property\n    def __metavar__(cls) -&gt; str:\n        # For Sphinx.\n        ...\n\n    @classmethod\n    def _metavar(cls) -&gt; str:\n        return f\"key{cls.item_separator}val{cls.sequence_separator}...\"\n\n    def __init__(self, values: Union[str, Mapping[_KT, _VT]]):\n        self._src = values\n\n        if isinstance(values, Mapping):\n            super().__init__(values)\n            return\n\n        kt: Type[_KT] = getattr(self, \"_kt\", typing.cast(Type[_KT], str))\n        vt: Type[_VT] = getattr(self, \"_vt\", typing.cast(Type[_VT], str))\n\n        if not values:\n            super().__init__()\n            return\n\n        dic = {}\n        for value in values.split(self.sequence_separator):\n            try:\n                kstr, vstr = value.split(self.item_separator, maxsplit=1)\n            except:\n                raise ValueError(\n                    f\"`{value}` is not a valid `{self.item_separator}` separated pair\"\n                ) from None\n            try:\n                k = kt(kstr)\n            except Exception as e:\n                raise ValueError(\n                    f\"`{kstr}` is not a valid `{kt.__name__}`: {e}\"\n                ) from None\n            try:\n                v = vt(vstr)\n            except Exception as e:\n                raise ValueError(\n                    f\"`{vstr}` is not a valid `{vt.__name__}`: {e}\"\n                ) from None\n            dic[k] = v\n        super().__init__(dic)\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self._src!r})\"\n\n    def __str__(self) -&gt; str:\n        return super().__repr__()\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types.SubClass","title":"corgy.types.SubClass","text":"<p>         Bases: <code>Generic[_T]</code></p> <p>Type representing a sub-class of a given class.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; from corgy.types import SubClass\n\n&gt;&gt;&gt; class Base: ...\n&gt;&gt;&gt; class Sub1(Base): ...\n&gt;&gt;&gt; class Sub2(Base): ...\n\n&gt;&gt;&gt; BaseSubType = SubClass[Base]   # type for a sub-class of `Base`\n&gt;&gt;&gt; BaseSub = BaseSubType(\"Sub1\")  # sub-class of `Base` named `Sub1`\n&gt;&gt;&gt; base_sub = BaseSub()           # instance of a sub-class of `Base`\n&gt;&gt;&gt; base_sub  # doctest: +SKIP\n&lt;Sub1 object at 0x100ea40a0&gt;\n</code></pre> <p>This class cannot be called directly. It first needs to be associated with a base class, using the <code>SubClass[Base]</code> syntax. This returns a new <code>SubClass</code> type, which is associated with <code>Base</code>. The returned type is callable, and accepts the name of a sub-class of <code>Base</code>. So, <code>SubClass[Base](\"Sub1\")</code> returns a <code>SubClass</code> type instance corresponding to the sub-class <code>Sub1</code> of <code>Base</code>. Finally, the <code>SubClass</code> instance can be called to create an instance of the sub-class, e.g., <code>SubClass[Base](\"Sub1\")()</code>.</p> <p>This class is useful for creating objects of a generic class, where the concrete class is determined at runtime, e.g, by a command-line argument::</p> <pre><code>&gt;&gt;&gt; from argparse import ArgumentParser\n\n&gt;&gt;&gt; parser = ArgumentParser()\n&gt;&gt;&gt; _ = parser.add_argument(\"--base-subcls\", type=SubClass[Base])\n\n&gt;&gt;&gt; args = parser.parse_args([\"--base-subcls\", \"Sub1\"])\n&gt;&gt;&gt; base_obj = args.base_subcls()  # an instance of a sub-class of `Base`\n</code></pre> <p>For further convenience when parsing command-line arguments, the class provides a <code>__choices__</code> property, which returns a tuple of all valid sub-classes, and can be passed as the <code>choices</code> argument to <code>ArgumentParser.add_argument</code>. Refer to the docstring of <code>__choices__</code> for more information.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <p>Name of the sub-class.</p> required <p>The behavior of sub-class type identification can be customized by setting class attributes (preferably on the type returned by the <code>[...]</code> syntax).</p> <ul> <li> <p><code>allow_base</code>: If <code>True</code>, the base class itself will be allowed as a valid     sub-class. The default is <code>False</code>. Example::</p> <pre><code>&gt;&gt;&gt; class Base: ...\n&gt;&gt;&gt; class Sub1(Base): ...\n&gt;&gt;&gt; class Sub2(Base): ...\n&gt;&gt;&gt; T = SubClass[Base]\n&gt;&gt;&gt; T.__choices__\n(SubClass[Base]('Sub1'), SubClass[Base]('Sub2'))\n&gt;&gt;&gt; T.allow_base = True\n&gt;&gt;&gt; T.__choices__\n(SubClass[Base]('Base'), SubClass[Base]('Sub1'), SubClass[Base]('Sub2'))\n</code></pre> </li> <li> <p><code>use_full_names</code>: If <code>True</code>, the name passed to the constructor needs to be the     full name of a sub-class, given by <code>cls.__module__ + \".\" + cls.__qualname__</code>. If     <code>False</code> (the default), the name needs to just be <code>cls.__name__</code>. This is useful     if the sub-classes are not uniquely identified by just their names.</p> </li> <li> <p><code>allow_indirect_subs</code>: If <code>True</code> (the default), indirect sub-classes, i.e.,     sub-classes of the base through another sub-class, are allowed. If <code>False</code>,     only direct sub-classes of the base are allowed. Example::</p> <pre><code>&gt;&gt;&gt; class Base: ...\n&gt;&gt;&gt; class Sub1(Base): ...\n&gt;&gt;&gt; class Sub2(Sub1): ...\n&gt;&gt;&gt; T = SubClass[Base]\n&gt;&gt;&gt; T.__choices__\n(SubClass[Base]('Sub1'), SubClass[Base]('Sub2'))\n&gt;&gt;&gt; T.allow_indirect_subs = False\n&gt;&gt;&gt; T.__choices__\n(SubClass[Base]('Sub1'),)\n</code></pre> </li> </ul> <p>Note that the types returned by the <code>SubClass[...]</code> syntax are cached using the base class type. So all instances of <code>SubClass[Base]</code> will return the same type, and any attributes set on the type will be shared between all instances.</p> Source code in <code>corgy/types/_subclass.py</code> <pre><code>class SubClass(Generic[_T], metaclass=_SubClassMeta):\n\"\"\"Type representing a sub-class of a given class.\n\n    Example::\n\n        &gt;&gt;&gt; from corgy.types import SubClass\n\n        &gt;&gt;&gt; class Base: ...\n        &gt;&gt;&gt; class Sub1(Base): ...\n        &gt;&gt;&gt; class Sub2(Base): ...\n\n        &gt;&gt;&gt; BaseSubType = SubClass[Base]   # type for a sub-class of `Base`\n        &gt;&gt;&gt; BaseSub = BaseSubType(\"Sub1\")  # sub-class of `Base` named `Sub1`\n        &gt;&gt;&gt; base_sub = BaseSub()           # instance of a sub-class of `Base`\n        &gt;&gt;&gt; base_sub  # doctest: +SKIP\n        &lt;Sub1 object at 0x100ea40a0&gt;\n\n    This class cannot be called directly. It first needs to be associated with a base\n    class, using the `SubClass[Base]` syntax. This returns a new `SubClass` type, which\n    is associated with `Base`. The returned type is callable, and accepts the name of a\n    sub-class of `Base`. So, `SubClass[Base](\"Sub1\")` returns a `SubClass` type instance\n    corresponding to the sub-class `Sub1` of `Base`. Finally, the `SubClass` instance\n    can be called to create an instance of the sub-class, e.g.,\n    `SubClass[Base](\"Sub1\")()`.\n\n    This class is useful for creating objects of a generic class, where the concrete\n    class is determined at runtime, e.g, by a command-line argument::\n\n        &gt;&gt;&gt; from argparse import ArgumentParser\n\n        &gt;&gt;&gt; parser = ArgumentParser()\n        &gt;&gt;&gt; _ = parser.add_argument(\"--base-subcls\", type=SubClass[Base])\n\n        &gt;&gt;&gt; args = parser.parse_args([\"--base-subcls\", \"Sub1\"])\n        &gt;&gt;&gt; base_obj = args.base_subcls()  # an instance of a sub-class of `Base`\n\n    For further convenience when parsing command-line arguments, the class provides a\n    `__choices__` property, which returns a tuple of all valid sub-classes, and can be\n    passed as the `choices` argument to `ArgumentParser.add_argument`. Refer to the\n    docstring of `__choices__` for more information.\n\n    Args:\n        name: Name of the sub-class.\n\n    The behavior of sub-class type identification can be customized by setting class\n    attributes (preferably on the type returned by the `[...]` syntax).\n\n    * `allow_base`: If `True`, the base class itself will be allowed as a valid\n        sub-class. The default is `False`. Example::\n\n            &gt;&gt;&gt; class Base: ...\n            &gt;&gt;&gt; class Sub1(Base): ...\n            &gt;&gt;&gt; class Sub2(Base): ...\n            &gt;&gt;&gt; T = SubClass[Base]\n            &gt;&gt;&gt; T.__choices__\n            (SubClass[Base]('Sub1'), SubClass[Base]('Sub2'))\n            &gt;&gt;&gt; T.allow_base = True\n            &gt;&gt;&gt; T.__choices__\n            (SubClass[Base]('Base'), SubClass[Base]('Sub1'), SubClass[Base]('Sub2'))\n\n    * `use_full_names`: If `True`, the name passed to the constructor needs to be the\n        full name of a sub-class, given by `cls.__module__ + \".\" + cls.__qualname__`. If\n        `False` (the default), the name needs to just be `cls.__name__`. This is useful\n        if the sub-classes are not uniquely identified by just their names.\n\n    * `allow_indirect_subs`: If `True` (the default), indirect sub-classes, i.e.,\n        sub-classes of the base through another sub-class, are allowed. If `False`,\n        only direct sub-classes of the base are allowed. Example::\n\n            &gt;&gt;&gt; class Base: ...\n            &gt;&gt;&gt; class Sub1(Base): ...\n            &gt;&gt;&gt; class Sub2(Sub1): ...\n            &gt;&gt;&gt; T = SubClass[Base]\n            &gt;&gt;&gt; T.__choices__\n            (SubClass[Base]('Sub1'), SubClass[Base]('Sub2'))\n            &gt;&gt;&gt; T.allow_indirect_subs = False\n            &gt;&gt;&gt; T.__choices__\n            (SubClass[Base]('Sub1'),)\n\n    Note that the types returned by the `SubClass[...]` syntax are cached using the\n    base class type. So all instances of `SubClass[Base]` will return the same type,\n    and any attributes set on the type will be shared between all instances.\n    \"\"\"\n\n    # The object cache is initialized inside `__class_getitem__`, so every concrete\n    # sub-type has its own object cache. The cache uses the sub-class name, along with\n    # the class config attributes as key, so that the cache is invalidated when any\n    # of the config attributes change.\n    _object_cache: Dict[Tuple[str, bool, bool, bool], \"SubClass[_T]\"]\n\n    allow_base: bool\n    use_full_names: bool\n    allow_indirect_subs: bool\n\n    _default_allow_base = False\n    _default_use_full_names = False\n    _default_allow_indirect_subs = True\n\n    _type_cache: Dict[Type[_T], Type[SubClass[_T]]] = {}\n\n    _base: Type[_T]\n\n    _subcls: Type[_T]\n    __metavar__ = \"cls\"\n    __slots__ = (\"_subcls\",)\n\n    def __class_getitem__(cls, item: Type[_T]) -&gt; Type[SubClass[_T]]:\n        if hasattr(cls, \"_base\"):\n            raise TypeError(\n                f\"cannot further sub-script \"\n                f\"`{cls.__name__}[{cls._subclass_name(cls._base)}]`\"\n            )\n        if not hasattr(item, \"__subclasses__\"):\n            raise TypeError(f\"`{item}` is not a valid class\")\n\n        try:\n            ret_type = cls._type_cache[item]\n        except (KeyError, TypeError) as e:\n            ret_type = type(\n                f\"{cls.__name__}[{item.__name__}]\",\n                (cls,),\n                {\n                    \"allow_base\": cls._default_allow_base,\n                    \"use_full_names\": cls._default_use_full_names,\n                    \"allow_indirect_subs\": cls._default_allow_indirect_subs,\n                    \"_base\": item,\n                    \"_object_cache\": {},\n                    \"__slots__\": cls.__slots__,\n                },\n            )\n            if not isinstance(e, TypeError):\n                # `TypeError` is raised if `item` is not hashable.\n                cls._type_cache[item] = ret_type\n            sys.modules[ret_type.__module__].__dict__[ret_type.__name__] = ret_type\n        return ret_type\n\n    def __getnewargs__(self):\n        return (self._subclass_name(self._subcls),)\n\n    @classmethod\n    def _ensure_base_set(cls):\n        if not hasattr(cls, \"_base\"):\n            raise TypeError(\n                f\"`{cls.__name__}` must be associated with a base class first: \"\n                f\"use `{cls.__name__}[&lt;class&gt;]`\"\n            )\n\n    @classmethod\n    def _generate_base_subclasses(cls) -&gt; Iterator[Type[_T]]:\n        cls._ensure_base_set()\n\n        def _iter_descendants(c):\n            for _s in c.__subclasses__():\n                yield _s\n                yield from _iter_descendants(_s)\n\n        if cls.allow_base:\n            yield cls._base\n\n        if cls.allow_indirect_subs:\n            yield from _iter_descendants(cls._base)\n        else:\n            for base_subcls in cls._base.__subclasses__():\n                yield base_subcls\n\n    @classmethod\n    def _subclass_name(cls, subcls: Type[_T]) -&gt; str:\n        if cls.use_full_names:\n            return subcls.__module__ + \".\" + subcls.__qualname__\n        return subcls.__name__\n\n    @property\n    def which(self) -&gt; Type[_T]:\n\"\"\"Return the class represented by the `SubClass` instance.\"\"\"\n        return self._subcls\n\n    @classmethod  # type: ignore\n    @property\n    def __choices__(cls) -&gt; Tuple[SubClass[_T], ...]:\n\"\"\"Return a tuple of `SubClass` instances for valid sub-classes of the base.\n\n        Each item in the tuple is an instance of `SubClass`, and corresponds to a valid\n        sub-class of the base-class associated with this type.\n        \"\"\"\n        # For Sphinx.\n\n    @classmethod\n    def _choices(cls) -&gt; Tuple[SubClass[_T], ...]:\n        cls._ensure_base_set()\n        choices: List[\"SubClass[_T]\"] = []\n        for subcls in cls._generate_base_subclasses():\n            obj = super().__new__(cls)\n            obj._subcls = subcls\n            choices.append(obj)\n        return tuple(choices)\n\n    def __new__(cls, name: str) -&gt; SubClass[_T]:  # pylint: disable=arguments-differ\n        cls._ensure_base_set()\n\n        cache_key = (name, cls.allow_base, cls.allow_indirect_subs, cls.use_full_names)\n        try:\n            return cls._object_cache[cache_key]\n        except KeyError:\n            pass\n\n        subcls = None\n        for subcls in cls._generate_base_subclasses():\n            if cls._subclass_name(subcls) == name:\n                break\n        else:\n            if subcls is None:\n                raise ValueError(f\"`{cls._base}` has no valid sub-classes\")\n            raise ValueError(f\"invalid sub-class name: `{name}`\")\n\n        obj = super().__new__(cls)\n        obj._subcls = subcls\n        cls._object_cache[cache_key] = obj\n        return obj\n\n    def __call__(self, *args, **kwargs) -&gt; _T:\n\"\"\"Return an instance of the sub-class associated with this type.\n\n        Example::\n\n            &gt;&gt;&gt; class Base: ...\n            &gt;&gt;&gt; class Sub1(Base):\n            ...     def __init__(self, x):\n            ...         print(f\"initializing `Sub1` with 'x={x}'\")\n\n            &gt;&gt;&gt; BaseSubType = SubClass[Base]\n            &gt;&gt;&gt; BaseSub = BaseSubType(\"Sub1\")  # an instance of the `SubClass` type\n\n            &gt;&gt;&gt; base_sub = BaseSub(1)\n            initializing `Sub1` with 'x=1'\n\n        \"\"\"\n        return self._subcls(*args, **kwargs)  # type: ignore\n\n    def __eq__(self, other: object) -&gt; bool:\n        if not isinstance(other, SubClass):\n            return False\n        return self._subcls is other._subcls\n\n    def __hash__(self) -&gt; int:\n        return hash(self._subcls)\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self._subclass_name(self._subcls)!r})\"\n\n    def __str__(self) -&gt; str:\n        return self._subclass_name(self._subcls)\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types._subclass.SubClass.__choices__","title":"__choices__  <code>property</code> <code>classmethod</code>","text":"<pre><code>__choices__: Tuple[SubClass[_T], ...]\n</code></pre> <p>Return a tuple of <code>SubClass</code> instances for valid sub-classes of the base.</p> <p>Each item in the tuple is an instance of <code>SubClass</code>, and corresponds to a valid sub-class of the base-class associated with this type.</p>"},{"location":"usage/corgy.types.html#corgy.types._subclass.SubClass.which","title":"which  <code>property</code>","text":"<pre><code>which: Type[_T]\n</code></pre> <p>Return the class represented by the <code>SubClass</code> instance.</p>"},{"location":"usage/corgy.types.html#corgy.types._subclass.SubClass.__call__","title":"__call__","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> <p>Return an instance of the sub-class associated with this type.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; class Base: ...\n&gt;&gt;&gt; class Sub1(Base):\n...     def __init__(self, x):\n...         print(f\"initializing `Sub1` with 'x={x}'\")\n\n&gt;&gt;&gt; BaseSubType = SubClass[Base]\n&gt;&gt;&gt; BaseSub = BaseSubType(\"Sub1\")  # an instance of the `SubClass` type\n\n&gt;&gt;&gt; base_sub = BaseSub(1)\ninitializing `Sub1` with 'x=1'\n</code></pre> Source code in <code>corgy/types/_subclass.py</code> <pre><code>def __call__(self, *args, **kwargs) -&gt; _T:\n\"\"\"Return an instance of the sub-class associated with this type.\n\n    Example::\n\n        &gt;&gt;&gt; class Base: ...\n        &gt;&gt;&gt; class Sub1(Base):\n        ...     def __init__(self, x):\n        ...         print(f\"initializing `Sub1` with 'x={x}'\")\n\n        &gt;&gt;&gt; BaseSubType = SubClass[Base]\n        &gt;&gt;&gt; BaseSub = BaseSubType(\"Sub1\")  # an instance of the `SubClass` type\n\n        &gt;&gt;&gt; base_sub = BaseSub(1)\n        initializing `Sub1` with 'x=1'\n\n    \"\"\"\n    return self._subcls(*args, **kwargs)  # type: ignore\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types.InitArgs","title":"corgy.types.InitArgs","text":"<p>         Bases: <code>Corgy</code>, <code>Generic[_T]</code></p> <p>Corgy wrapper around arguments of a class's <code>__init__</code>.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; import argparse\n&gt;&gt;&gt; from argparse import ArgumentParser\n&gt;&gt;&gt; from typing import Sequence\n&gt;&gt;&gt; from corgy import CorgyHelpFormatter\n&gt;&gt;&gt; from corgy.types import InitArgs\n\n&gt;&gt;&gt; class Foo:\n...     def __init__(\n...         self,\n...         a: int,\n...         b: Sequence[str],\n...         c: float = 0.0,\n...     ):\n...         ...\n\n&gt;&gt;&gt; FooInitArgs = InitArgs[Foo]\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n&gt;&gt;&gt; FooInitArgs.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --a int        (required)\n  --b [str ...]  (required)\n  --c float      (default: 0.0)\n\n&gt;&gt;&gt; args = parser.parse_args([\"--a\", \"1\", \"--b\", \"one\", \"two\"])\n&gt;&gt;&gt; foo = Foo(args.a, args.b, args.c)\n</code></pre> <p>This is a generic class, and on using the <code>InitArgs[Cls]</code> syntax, a concrete <code>Corgy</code> class is created, which has attributes corresponding to the arguments of <code>Cls.__init__</code>, with types inferred from annotations. The returned class can be used as any other <code>Corgy</code> class, including as a type annotation within another <code>Corgy</code> class.</p> <p>All arguments of the <code>__init__</code> method must be annotated, following the same rules as for other <code>Corgy</code> classes. Positional only arguments are not supported, since they are not associated with an argument name. <code>TypeError</code> is raised if either of these conditions is not met.</p> Source code in <code>corgy/types/_initargs.py</code> <pre><code>class InitArgs(Corgy, Generic[_T], corgy_required_by_default=True):\n\"\"\"Corgy wrapper around arguments of a class's `__init__`.\n\n    Example::\n\n        &gt;&gt;&gt; import argparse\n        &gt;&gt;&gt; from argparse import ArgumentParser\n        &gt;&gt;&gt; from typing import Sequence\n        &gt;&gt;&gt; from corgy import CorgyHelpFormatter\n        &gt;&gt;&gt; from corgy.types import InitArgs\n\n        &gt;&gt;&gt; class Foo:\n        ...     def __init__(\n        ...         self,\n        ...         a: int,\n        ...         b: Sequence[str],\n        ...         c: float = 0.0,\n        ...     ):\n        ...         ...\n\n        &gt;&gt;&gt; FooInitArgs = InitArgs[Foo]\n        &gt;&gt;&gt; parser = ArgumentParser(\n        ...     formatter_class=CorgyHelpFormatter,\n        ...     add_help=False,\n        ...     usage=argparse.SUPPRESS,\n        ... )\n        &gt;&gt;&gt; FooInitArgs.add_args_to_parser(parser)\n        &gt;&gt;&gt; parser.print_help()\n        options:\n          --a int        (required)\n          --b [str ...]  (required)\n          --c float      (default: 0.0)\n\n        &gt;&gt;&gt; args = parser.parse_args([\"--a\", \"1\", \"--b\", \"one\", \"two\"])\n        &gt;&gt;&gt; foo = Foo(args.a, args.b, args.c)\n\n    This is a generic class, and on using the `InitArgs[Cls]` syntax, a concrete\n    `Corgy` class is created, which has attributes corresponding to the arguments of\n    `Cls.__init__`, with types inferred from annotations. The returned class can be used\n    as any other `Corgy` class, including as a type annotation within another `Corgy`\n    class.\n\n    All arguments of the `__init__` method must be annotated, following the same rules\n    as for other `Corgy` classes. Positional only arguments are not supported, since\n    they are not associated with an argument name. `TypeError` is raised if either of\n    these conditions is not met.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __class_getitem__(cls, item: Type[_T]) -&gt; Type[InitArgs[_T]]:\n        try:\n            is_generic = issubclass(item, Generic)  # type: ignore\n        except TypeError as e:\n            raise TypeError(f\"could not perform class test on `{item}`: {e}\") from None\n        if is_generic:\n            raise TypeError(f\"{cls.__name__} cannot be used with generic classes\")\n        item_sig = inspect.signature(item)\n        item_annotations, item_defaults = {}, {}\n        for param_name, param in item_sig.parameters.items():\n            if param.annotation is inspect.Parameter.empty:\n                raise TypeError(\n                    f\"`{item}` is missing annotation for parameter `{param_name}`\"\n                )\n\n            if param.kind is inspect.Parameter.POSITIONAL_ONLY:\n                raise TypeError(\n                    f\"positional-only paramter `{param_name}` is incompatible with \"\n                    f\"`{cls.__name__}`\"\n                )\n\n            item_annotations[param_name] = param.annotation\n            if param.default is not inspect.Parameter.empty:\n                item_defaults[param_name] = param.default\n\n        def new_cls_getitem(newcls, _item: Type[_T]) -&gt; NoReturn:\n            raise TypeError(\n                f\"cannot further sub-script `{newcls.__name__}[{_item.__name__}]`\"\n            )\n\n        ret_type = type(\n            f\"{cls.__name__}[{item.__name__}]\",\n            (cls,),\n            {\n                \"__annotations__\": item_annotations,\n                \"__module__\": item.__module__,\n                \"__class_getitem__\": new_cls_getitem,\n                **item_defaults,\n            },\n        )\n        sys.modules[ret_type.__module__].__dict__[ret_type.__name__] = ret_type\n        return ret_type\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types.InputTextFile","title":"corgy.types.InputTextFile","text":"<p>         Bases: <code>TextIOWrapper</code></p> <p><code>TextIOWrapper</code> sub-class representing an input file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>StrPath</code> <p>Path to a file.</p> required <p>The file must exist, and will be opened in text mode (<code>r</code>). <code>ValueError</code> is raised if this fails. An <code>atexit</code> handler will be registered to close the file on program termination.</p> Source code in <code>corgy/types/_inputfile.py</code> <pre><code>@expand_with_init\nclass InputTextFile(TextIOWrapper):\n\"\"\"`TextIOWrapper` sub-class representing an input file.\n\n    Args:\n        path: Path to a file.\n\n    The file must exist, and will be opened in text mode (`r`). `ValueError` is\n    raised if this fails. An `atexit` handler will be registered to close the file on\n    program termination.\n    \"\"\"\n\n    __metavar__ = \"file\"\n    __slots__ = ()\n\n    def __init__(self, path: StrPath):\n        try:\n            stream = FileIO(str(path), \"r\")\n        except OSError as e:\n            raise ValueError(f\"could not open `{path}`: {e}\") from None\n        buffer = BufferedReader(stream)\n        super().__init__(buffer)\n        atexit.register(self.__class__.close, self)\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self.buffer.name!r})\"\n\n    def __str__(self) -&gt; str:\n        return str(self.buffer.name)\n\n    @classmethod\n    def stdin_wrapper(cls) -&gt; InputTextFile:\n\"\"\"`sys.__stdin__` as `InputTextFile`.\"\"\"\n        obj = cls.__new__(cls)\n        TextIOWrapper.__init__(obj, sys.__stdin__.buffer, line_buffering=True)\n        atexit.register(cls.close, obj)\n        return obj\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types._inputfile.InputTextFile.stdin_wrapper","title":"stdin_wrapper  <code>classmethod</code>","text":"<pre><code>stdin_wrapper()\n</code></pre> <p><code>sys.__stdin__</code> as <code>InputTextFile</code>.</p> Source code in <code>corgy/types/_inputfile.py</code> <pre><code>@classmethod\ndef stdin_wrapper(cls) -&gt; InputTextFile:\n\"\"\"`sys.__stdin__` as `InputTextFile`.\"\"\"\n    obj = cls.__new__(cls)\n    TextIOWrapper.__init__(obj, sys.__stdin__.buffer, line_buffering=True)\n    atexit.register(cls.close, obj)\n    return obj\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types.InputBinFile","title":"corgy.types.InputBinFile","text":"<p>         Bases: <code>BufferedReader</code></p> <p>Type for an input binary file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>StrPath</code> <p>Path to a file.</p> required <p>This class is a thin wrapper around <code>BufferedReader</code> that accepts a path, instead of a file stream. The file must exist, and will be opened in binary mode. <code>ValueError</code> is raised if this fails. An <code>atexit</code> handler will be registered to close the file on program termination.</p> Source code in <code>corgy/types/_inputfile.py</code> <pre><code>@expand_with_init\nclass InputBinFile(BufferedReader):\n\"\"\"Type for an input binary file.\n\n    Args:\n        path: Path to a file.\n\n    This class is a thin wrapper around `BufferedReader` that accepts a path, instead\n    of a file stream. The file must exist, and will be opened in binary mode.\n    `ValueError` is raised if this fails. An `atexit` handler will be registered\n    to close the file on program termination.\n    \"\"\"\n\n    __metavar__ = \"file\"\n    __slots__ = ()\n\n    def __init__(self, path: StrPath):\n        try:\n            stream = FileIO(str(path), \"rb\")\n        except OSError as e:\n            raise ValueError(f\"could not open `{path}`: {e}\") from None\n        super().__init__(stream)\n        atexit.register(self.__class__.close, self)\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self.name!r})\"\n\n    def __str__(self) -&gt; str:\n        return str(self.name)\n\n    @classmethod\n    def stdin_wrapper(cls) -&gt; Self:\n\"\"\"`sys.__stdin__` as `InputBinFile`.\"\"\"\n        obj = cls.__new__(cls)\n        stream = FileIO(sys.__stdin__.fileno(), mode=\"rb\")\n        BufferedReader.__init__(obj, stream)\n        atexit.register(cls.close, obj)\n        return obj\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types._inputfile.InputBinFile.stdin_wrapper","title":"stdin_wrapper  <code>classmethod</code>","text":"<pre><code>stdin_wrapper()\n</code></pre> <p><code>sys.__stdin__</code> as <code>InputBinFile</code>.</p> Source code in <code>corgy/types/_inputfile.py</code> <pre><code>@classmethod\ndef stdin_wrapper(cls) -&gt; Self:\n\"\"\"`sys.__stdin__` as `InputBinFile`.\"\"\"\n    obj = cls.__new__(cls)\n    stream = FileIO(sys.__stdin__.fileno(), mode=\"rb\")\n    BufferedReader.__init__(obj, stream)\n    atexit.register(cls.close, obj)\n    return obj\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types.OutputTextFile","title":"corgy.types.OutputTextFile","text":"<p>         Bases: <code>TextIOWrapper</code></p> <p><code>TextIOWrapper</code> sub-class representing an output file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>StrPath</code> <p>Path to a file.</p> required <p>The file will be created if it does not exist (including any parent directories), and opened in text mode (<code>w</code>). Existing files will be truncated. <code>ValueError</code> is raised if any of the operations fail. An <code>atexit</code> handler will be registered to close the file on program termination.</p> Source code in <code>corgy/types/_outputfile.py</code> <pre><code>@expand_with_init\nclass OutputTextFile(TextIOWrapper):\n\"\"\"`TextIOWrapper` sub-class representing an output file.\n\n    Args:\n        path: Path to a file.\n\n    The file will be created if it does not exist (including any parent directories),\n    and opened in text mode (`w`). Existing files will be truncated. `ValueError`\n    is raised if any of the operations fail. An `atexit` handler will be registered to\n    close the file on program termination.\n    \"\"\"\n\n    __metavar__ = \"file\"\n    __slots__ = ()\n\n    def __init__(self, path: StrPath):\n        stream = _get_output_stream(path, \"w\")\n        buffer = BufferedWriter(stream)\n        super().__init__(buffer)\n        atexit.register(self.__class__.close, self)\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self.buffer.name!r})\"\n\n    def __str__(self) -&gt; str:\n        return str(self.buffer.name)\n\n    def init(self):\n\"\"\"No-op for compatibility with `LazyOutputTextFile`.\"\"\"\n\n    @classmethod\n    def _stdoe_wrapper(cls, f: TextIOWrapper) -&gt; Self:\n        obj = cls.__new__(cls)\n        TextIOWrapper.__init__(obj, f.buffer, line_buffering=True)\n        atexit.register(cls.close, obj)\n        return obj\n\n    @classmethod\n    def stdout_wrapper(cls) -&gt; Self:\n\"\"\"`sys.__stdout__` as `OutputTextFile`.\"\"\"\n        return cls._stdoe_wrapper(sys.__stdout__)\n\n    @classmethod\n    def stderr_wrapper(cls) -&gt; Self:\n\"\"\"`sys.__stderr__` as `OutputTextFile`.\"\"\"\n        return cls._stdoe_wrapper(sys.__stderr__)\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.OutputTextFile.init","title":"init","text":"<pre><code>init()\n</code></pre> <p>No-op for compatibility with <code>LazyOutputTextFile</code>.</p> Source code in <code>corgy/types/_outputfile.py</code> <pre><code>def init(self):\n\"\"\"No-op for compatibility with `LazyOutputTextFile`.\"\"\"\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.OutputTextFile.stderr_wrapper","title":"stderr_wrapper  <code>classmethod</code>","text":"<pre><code>stderr_wrapper()\n</code></pre> <p><code>sys.__stderr__</code> as <code>OutputTextFile</code>.</p> Source code in <code>corgy/types/_outputfile.py</code> <pre><code>@classmethod\ndef stderr_wrapper(cls) -&gt; Self:\n\"\"\"`sys.__stderr__` as `OutputTextFile`.\"\"\"\n    return cls._stdoe_wrapper(sys.__stderr__)\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.OutputTextFile.stdout_wrapper","title":"stdout_wrapper  <code>classmethod</code>","text":"<pre><code>stdout_wrapper()\n</code></pre> <p><code>sys.__stdout__</code> as <code>OutputTextFile</code>.</p> Source code in <code>corgy/types/_outputfile.py</code> <pre><code>@classmethod\ndef stdout_wrapper(cls) -&gt; Self:\n\"\"\"`sys.__stdout__` as `OutputTextFile`.\"\"\"\n    return cls._stdoe_wrapper(sys.__stdout__)\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types.LazyOutputTextFile","title":"corgy.types.LazyOutputTextFile","text":"<p>         Bases: <code>OutputTextFile</code></p> <p><code>OutputTextFile</code> sub-class that does not auto-initialize.</p> <p>Useful for \"default\" files, which only need to be created if an alternative is not provided. <code>init</code> must be called on instances before they can be used.</p> Source code in <code>corgy/types/_outputfile.py</code> <pre><code>@expand_with_init\nclass LazyOutputTextFile(OutputTextFile):\n\"\"\"`OutputTextFile` sub-class that does not auto-initialize.\n\n    Useful for \"default\" files, which only need to be created if an alternative is not\n    provided. `init` must be called on instances before they can be used.\n    \"\"\"\n\n    __slots__ = (\"_path\",)\n\n    def __init__(self, path: StrPath):\n        # pylint: disable=super-init-not-called\n        self._path = path\n\n    def init(self):\n\"\"\"Initialize the file.\"\"\"\n        super().__init__(self._path)\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.LazyOutputTextFile.init","title":"init","text":"<pre><code>init()\n</code></pre> <p>Initialize the file.</p> Source code in <code>corgy/types/_outputfile.py</code> <pre><code>def init(self):\n\"\"\"Initialize the file.\"\"\"\n    super().__init__(self._path)\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types.OutputBinFile","title":"corgy.types.OutputBinFile","text":"<p>         Bases: <code>BufferedWriter</code></p> <p>Type for an output binary file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>StrPath</code> <p>Path to a file.</p> required <p>This class is a thin wrapper around <code>BufferedWriter</code> that accepts a path, instead of a file stream. The file will be created if it does not exist (including any parent directories), and opened in binary mode. Existing files will be truncated. <code>ValueError</code> is raised if any of the operations fail. An <code>atexit</code> handler will be registered to close the file on program termination.</p> Source code in <code>corgy/types/_outputfile.py</code> <pre><code>@expand_with_init\nclass OutputBinFile(BufferedWriter):\n\"\"\"Type for an output binary file.\n\n    Args:\n        path: Path to a file.\n\n    This class is a thin wrapper around `BufferedWriter` that accepts a path, instead\n    of a file stream. The file will be created if it does not exist (including any\n    parent directories), and opened in binary mode. Existing files will be truncated.\n    `ValueError` is raised if any of the operations fail. An `atexit` handler\n    will be registered to close the file on program termination.\n    \"\"\"\n\n    __metavar__ = \"file\"\n    __slots__ = ()\n\n    def __init__(self, path: StrPath):\n        stream = _get_output_stream(path, \"wb\")\n        super().__init__(stream)\n        atexit.register(self.__class__.close, self)\n\n    def __repr__(self) -&gt; str:\n        return f\"{self.__class__.__name__}({self.name!r})\"\n\n    def __str__(self) -&gt; str:\n        return str(self.name)\n\n    def init(self):\n\"\"\"No-op for compatibility with `LazyOutputBinFile`.\"\"\"\n\n    @classmethod\n    def _stdoe_wrapper(cls, f: TextIOWrapper) -&gt; Self:\n        obj = cls.__new__(cls)\n        stream = FileIO(f.fileno(), mode=\"wb\")\n        BufferedWriter.__init__(obj, stream)\n        atexit.register(cls.close, obj)\n        return obj\n\n    @classmethod\n    def stdout_wrapper(cls) -&gt; Self:\n\"\"\"`sys.__stdout__` as `OutputBinFile`.\"\"\"\n        return cls._stdoe_wrapper(sys.__stdout__)\n\n    @classmethod\n    def stderr_wrapper(cls) -&gt; Self:\n\"\"\"`sys.__stderr__` as `OutputBinFile`.\"\"\"\n        return cls._stdoe_wrapper(sys.__stderr__)\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.OutputBinFile.init","title":"init","text":"<pre><code>init()\n</code></pre> <p>No-op for compatibility with <code>LazyOutputBinFile</code>.</p> Source code in <code>corgy/types/_outputfile.py</code> <pre><code>def init(self):\n\"\"\"No-op for compatibility with `LazyOutputBinFile`.\"\"\"\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.OutputBinFile.stderr_wrapper","title":"stderr_wrapper  <code>classmethod</code>","text":"<pre><code>stderr_wrapper()\n</code></pre> <p><code>sys.__stderr__</code> as <code>OutputBinFile</code>.</p> Source code in <code>corgy/types/_outputfile.py</code> <pre><code>@classmethod\ndef stderr_wrapper(cls) -&gt; Self:\n\"\"\"`sys.__stderr__` as `OutputBinFile`.\"\"\"\n    return cls._stdoe_wrapper(sys.__stderr__)\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.OutputBinFile.stdout_wrapper","title":"stdout_wrapper  <code>classmethod</code>","text":"<pre><code>stdout_wrapper()\n</code></pre> <p><code>sys.__stdout__</code> as <code>OutputBinFile</code>.</p> Source code in <code>corgy/types/_outputfile.py</code> <pre><code>@classmethod\ndef stdout_wrapper(cls) -&gt; Self:\n\"\"\"`sys.__stdout__` as `OutputBinFile`.\"\"\"\n    return cls._stdoe_wrapper(sys.__stdout__)\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types.LazyOutputBinFile","title":"corgy.types.LazyOutputBinFile","text":"<p>         Bases: <code>OutputBinFile</code></p> <p><code>OutputBinFile</code> sub-class that does not auto-initialize.</p> <p>Useful for \"default\" files, which only need to be created if an alternative is not provided. <code>init</code> must be called on instances before they can be used.</p> Source code in <code>corgy/types/_outputfile.py</code> <pre><code>@expand_with_init\nclass LazyOutputBinFile(OutputBinFile):\n\"\"\"`OutputBinFile` sub-class that does not auto-initialize.\n\n    Useful for \"default\" files, which only need to be created if an alternative is not\n    provided. `init` must be called on instances before they can be used.\n    \"\"\"\n\n    __slots__ = (\"_path\",)\n\n    def __init__(self, path: StrPath):\n        # pylint: disable=super-init-not-called\n        self._path = path\n\n    def init(self):\n\"\"\"Initialize the file.\"\"\"\n        super().__init__(self._path)\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.LazyOutputBinFile.init","title":"init","text":"<pre><code>init()\n</code></pre> <p>Initialize the file.</p> Source code in <code>corgy/types/_outputfile.py</code> <pre><code>def init(self):\n\"\"\"Initialize the file.\"\"\"\n    super().__init__(self._path)\n</code></pre>"}]}