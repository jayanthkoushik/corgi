var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"corgy","text":"<p>Corgy is a Python library that allows you to create feature rich data classes using intuitive type annotations.</p> <pre><code>&gt;&gt;&gt; from typing import List\n&gt;&gt;&gt; from typing_extensions import Literal\n&gt;&gt;&gt; from corgy import Corgy\n&gt;&gt;&gt; from corgy.types import KeyValuePairs\n\n&gt;&gt;&gt; class G(Corgy):\n...     x: int\n...     y: Literal[\"y1\", \"y2\", \"y3\"]\n\n&gt;&gt;&gt; class C(Corgy):\n...     x: List[float] = [1.0, 2.0]\n...     y: KeyValuePairs[str, int]\n...     g: G\n</code></pre>"},{"location":"index.html#features","title":"Features","text":"<ul> <li>Type checking: <code>Corgy</code> instances are type-checked, and support a   number of type modifiers.</li> </ul> <pre><code>&gt;&gt;&gt; from typing import Tuple\n\n&gt;&gt;&gt; class C(Corgy):\n...     x: int\n...     y: Tuple[int, int]\n\n&gt;&gt;&gt; C(x=\"1\")\nTraceback (most recent call last):\n...\nValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n\n&gt;&gt;&gt; C(y=(1, 2, 3))\nTraceback (most recent call last):\n...\nValueError: error setting `y`: invalid value for type 'typing.Tuple[int, int]': (1, 2, 3): expected exactly '2' elements\n</code></pre> <ul> <li>Dictionary interface: <code>Corgy</code> instances can be converted to/from   dictionaries.</li> </ul> <pre><code>&gt;&gt;&gt; class G(Corgy):\n...     x: int\n\n&gt;&gt;&gt; class C(Corgy):\n...     x: int\n...     g: G\n\n&gt;&gt;&gt; g = G.from_dict({\"x\": 1})\n&gt;&gt;&gt; g\nG(x=1)\n\n&gt;&gt;&gt; c = C(x=2, g=g)\n&gt;&gt;&gt; c.as_dict()\n{'x': 2, 'g': {'x': 1}}\n</code></pre> <ul> <li>Command-line parsing: <code>Corgy</code> class attributes can be added to an   <code>ArgumentParser</code> instance, and parsed from the command-line. Help   messages can be added to attributes with <code>Annotated</code>, and will be   passed to the command line parser.</li> </ul> <pre><code>&gt;&gt;&gt; from argparse import ArgumentParser\n&gt;&gt;&gt; from typing import Optional\n&gt;&gt;&gt; from typing_extensions import Annotated\n\n&gt;&gt;&gt; class ArgGroup(Corgy):\n...     arg1: Annotated[Optional[int], \"optional number\"]\n...     arg2: Annotated[bool, \"a boolean\"]\n\n&gt;&gt;&gt; class MyArgs(Corgy):\n...     arg1: Annotated[int, \"a number\"] = 1\n...     arg2: Annotated[Tuple[float, ...], \"at least one float\"]\n...     grp1: Annotated[ArgGroup, \"group 1\"]\n\n&gt;&gt;&gt; parser = ArgumentParser(usage=\"\")\n&gt;&gt;&gt; MyArgs.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()  # doctest: +SKIP\nusage:\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --arg1 ARG1           a number\n  --arg2 ARG2 [ARG2 ...]\n                        at least one float\n\ngrp1:\n  group 1\n\n  --grp1:arg1 [GRP1:ARG1]\n                        optional number\n  --grp1:arg2, --no-grp1:arg2\n                        a boolean\n</code></pre> <ul> <li>Enhanced argparse formatting: The <code>corgy</code> package provides   <code>CorgyHelpFormatter</code>, a formatter class for <code>argparse</code>, with support   for colorized output. It can also be used independent of <code>Corgy</code>   classes.</li> </ul> <pre><code>&gt;&gt;&gt; from corgy import CorgyHelpFormatter\n\n&gt;&gt;&gt; # `ArgGroup` and `MyArgs` as defined above\n&gt;&gt;&gt; parser = ArgumentParser(usage=\"\", formatter_class=CorgyHelpFormatter)\n&gt;&gt;&gt; MyArgs.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()  # doctest: +SKIP\n</code></pre> <ul> <li>Convenience types: <code>corgy.types</code> provides a number of types for   converting strings into objects like paths, dictionaries, classes,   etc. These can be used standalone, but are especially useful for   parsing from command line arguments. Refer to the docs for details on   all available types. A small example is shown below.</li> </ul> <pre><code>&gt;&gt;&gt; T = KeyValuePairs[str, int]\n&gt;&gt;&gt; m = T(\"x=1,y=2\")\n&gt;&gt;&gt; print(m)\n{'x': 1, 'y': 2}\n</code></pre>"},{"location":"index.html#install","title":"Install","text":"<p><code>corgy</code> is available on PyPI, and can be installed with pip:</p> <pre><code>pip install corgy\n</code></pre> <p>Support for colorized output requires the <code>crayons</code> package, also available on PyPI. You can pull it as a dependency for <code>corgy</code> by installing with the <code>colors</code> extra:</p> <pre><code>pip install corgy[colors]\n</code></pre> <p>Parsing <code>Corgy</code> objects from <code>toml</code> files requires the <code>tomli</code> package on Python versions below 3.11. This can be installed automatically with the <code>toml</code> extra:</p> <pre><code>pip install corgy[toml]\n</code></pre>"},{"location":"usage/corgy.html","title":"corgy","text":""},{"location":"usage/corgy.html#corgy.Corgy","title":"corgy.Corgy","text":"<p>Base class for collections of attributes.</p> <p>To use, subclass <code>Corgy</code>, and declare attributes using type annotations::</p> <pre><code>&gt;&gt;&gt; from corgy import Corgy\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: float\n</code></pre> <p>At runtime, class <code>A</code> will have <code>x</code>, and <code>y</code> as properties, so that the class can be used similar to Python dataclasses::</p> <pre><code>&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = 1\n&gt;&gt;&gt; a.x\n1\n\n&gt;&gt;&gt; a.y\nTraceback (most recent call last):\n   ...\nAttributeError: no value available for attribute `y`\n\n&gt;&gt;&gt; a.y = a.x + 1.1\n&gt;&gt;&gt; a.y\n2.1\n\n&gt;&gt;&gt; del a.x  # unset x\n&gt;&gt;&gt; a.x\nTraceback (most recent call last):\n   ...\nAttributeError: no value available for attribute `x`\n</code></pre> <p>Note that the class's <code>__init__</code> method only accepts keyword arguments, and ignores arguments without a corresponding attribute. The following are all valid::</p> <pre><code>&gt;&gt;&gt; A(x=1, y=2.1)\nA(x=1, y=2.1)\n\n&gt;&gt;&gt; A(x=1, z=3)  # y is not set, and z is ignored\nA(x=1)\n\n&gt;&gt;&gt; A(**{\"x\": 1, \"y\": 2.1, \"z\": 3})\nA(x=1, y=2.1)\n</code></pre> <p>Attribute values are type-checked, and <code>ValueError</code> is raised on type mismatch::</p> <pre><code>&gt;&gt;&gt; a = A(x=\"1\")\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = \"1\"\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: int = \"1\"\nTraceback (most recent call last):\n    ...\nValueError: default value type mismatch for 'x'\n</code></pre> <p>Any type which supports type checking with <code>isinstance</code> can be used as an attribute type (along with some special type annotations that are discussed below). This includes other corgy classes::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: float\n\n&gt;&gt;&gt; class B(Corgy):\n...     x: int\n...     a: A\n\n&gt;&gt;&gt; b = B(x=1)\n&gt;&gt;&gt; b.a = A()\n&gt;&gt;&gt; b.a.x = 10\n&gt;&gt;&gt; b\nB(x=1, a=A(x=10))\n</code></pre> <p><code>Corgy</code> classes have their <code>__slots__</code> set to the annotated attributes. So, if you want to use additional attributes not tracked by <code>Corgy</code>, define them (and only them) in <code>__slots__</code>::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     __slots__ = (\"x\",)\n...     y: int\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.y = 1  # `Corgy` attribute\n&gt;&gt;&gt; a.x = 2  # custom attribute\n&gt;&gt;&gt; a\nA(y=1)\n</code></pre> <p>To allow arbitrary instance attributes, add <code>__dict__</code> to <code>__slots__</code>. Names added through custom <code>__slots__</code> are not processed by <code>Corgy</code>. Alternatively, to disable setting <code>__slots__</code> completely, set <code>corgy_make_slots</code> to <code>False</code> in the class definition::</p> <pre><code>&gt;&gt;&gt; class A(Corgy, corgy_make_slots=False):\n...     y: int\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.y = 1  # `Corgy` attribute\n&gt;&gt;&gt; a.x = 2  # custom attribute\n&gt;&gt;&gt; a\nA(y=1)\n</code></pre> <p>Names marked with the <code>ClassVar</code> type will be added as class variables, and will not be available as <code>Corgy</code> attributes::</p> <pre><code>&gt;&gt;&gt; from typing import ClassVar\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: ClassVar[int] = 3\n\n&gt;&gt;&gt; A.x\n3\n&gt;&gt;&gt; A.x = 4\n&gt;&gt;&gt; A.x\n4\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x\n4\n&gt;&gt;&gt; a.x = 5\nTraceback (most recent call last):\n    ...\nAttributeError: 'A' object attribute 'x' is read-only\n</code></pre> <p>Also note that class variables need to be assigned to a value during definition, and this value will not be type checked by <code>Corgy</code>.</p> <p>Inheritance works as expected, whether base classes are themselves <code>Corgy</code> classes or not, with sub-classes inheriting the attributes of the base class, and overriding any redefined attributes::</p> <pre><code>&gt;&gt;&gt; class A:\n...     x: int\n\n&gt;&gt;&gt; class B(Corgy, A):\n...     y: float = 1.0\n...     z: str\n\n&gt;&gt;&gt; class C(B):\n...     y: float = 2.0\n...     z: str\n...     w: float\n\n&gt;&gt;&gt; c = C()\n&gt;&gt;&gt; print(c)\nC(x=&lt;unset&gt;, y=2.0, z=&lt;unset&gt;, w=&lt;unset&gt;)\n</code></pre> <p>Tracking of base class attributes can be disabled by setting <code>corgy_track_bases</code> to <code>False</code> in the class definition. Properties will still be inherited following standard inheritance rules, but <code>Corgy</code> will ignore them::</p> <pre><code>&gt;&gt;&gt; class A:\n...     x: int\n\n&gt;&gt;&gt; class B(Corgy, A, corgy_track_bases=False):\n...     y: float = 1.0\n...     z: str\n\n&gt;&gt;&gt; b = B()\n&gt;&gt;&gt; print(b)\nB(y=1.0, z=&lt;unset&gt;)\n</code></pre> <p><code>Corgy</code> instances can be frozen (preventing any further changes) using the <code>freeze</code> method. This method can be called automatically after <code>__init__</code> by by setting <code>corgy_freeze_after_init</code> to <code>True</code> in the class definition::</p> <pre><code>&gt;&gt;&gt; class A(Corgy, corgy_freeze_after_init=True):\n...    x: int\n\n&gt;&gt;&gt; a = A(x=1)\n&gt;&gt;&gt; a.x = 2\nTraceback (most recent call last):\n    ...\nTypeError: cannot set `x`: object is frozen\n</code></pre> <p><code>Corgy</code> recognizes a number of special annotations, which are used to control how attribute values are processed.</p> Note <p>If any of the following annotations are unavailable in the Python version being used, you can import them from <code>typing_extensions</code> (which is available on PyPI).</p> <p>Annotations <code>typing.Annotated</code> can be used to add additional metadata to attributes, akin to doc strings. It is primarily used to control how attributes are added to <code>ArgumentParser</code> instances. <code>typing.Annotated</code> is stripped on class creation, leaving only the base type::</p> <pre><code>&gt;&gt;&gt; import sys\n&gt;&gt;&gt; if sys.version_info &gt;= (3, 9):\n...     from typing import Annotated, Literal\n... else:\n...     from typing_extensions import Annotated, Literal\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Annotated[int, \"this is x\"]\n\n&gt;&gt;&gt; A.attrs()\n{'x': &lt;class 'int'&gt;}\n</code></pre> <p><code>Annotated</code> should always be the outermost type annotation for an attribute. Refer to the docs for <code>Corgy.add_args_to_parser</code> for details on usage.</p> <p>Required/NotRequired By default, <code>Corgy</code> attributes are not required, and can be unset. This can be changed by setting <code>corgy_required_by_default</code> to <code>True</code> in the class definition::</p> <pre><code>&gt;&gt;&gt; class A(Corgy, corgy_required_by_default=True):\n...     x: int\n\n&gt;&gt;&gt; A()\nTraceback (most recent call last):\n    ...\nValueError: missing required attribute: `x`\n&gt;&gt;&gt; a = A(x=1)\n&gt;&gt;&gt; del a.x\nTraceback (most recent call last):\n    ...\nTypeError: attribute `x` cannot be unset\n</code></pre> <p>Attributes can also explicitly be marked as required/not-required using <code>corgy.Required</code> and <code>corgy.NotRequired</code> annotations::</p> <pre><code>&gt;&gt;&gt; from corgy import Required, NotRequired\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Required[int]\n...     y: NotRequired[int]\n...     z: int  # not required by default\n\n&gt;&gt;&gt; a = A(x=1)\n&gt;&gt;&gt; print(a)\nA(x=1, y=&lt;unset&gt;, z=&lt;unset&gt;)\n\n&gt;&gt;&gt; class B(Corgy, corgy_required_by_default=True):\n...     x: Required[int]\n...     y: NotRequired[int]\n...     z: int\n\n&gt;&gt;&gt; b = B(x=1, z=2)\n&gt;&gt;&gt; print(b)\nB(x=1, y=&lt;unset&gt;, z=2)\n</code></pre> <p>Optional Annotating an attribute with <code>typing.Optional</code> allows it to be <code>None</code>::</p> <pre><code>&gt;&gt;&gt; from typing import Optional\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Optional[int]\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = None\n</code></pre> <p>In Python &gt;= 3.10, instead of using <code>typing.Annotated</code>, <code>| None</code> can be used, i.e., <code>x: int | None</code> for example.</p> <p>Note that <code>Optional</code> is not the same as <code>NotRequired</code>. <code>Optional</code> allows an attribute to be <code>None</code>, while <code>NotRequired</code> allows an attribute to be unset. A <code>Required</code> <code>Optional</code> attribute will need a value (which can be <code>None</code>)::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Required[Optional[int]]\n\n&gt;&gt;&gt; A()\nTraceback (most recent call last):\n    ...\nValueError: missing required attribute: `x`\n&gt;&gt;&gt; a = A(x=None)\n&gt;&gt;&gt; print(a)\nA(x=None)\n</code></pre> <p>Collections Several collection types can be used to annotate attributes, which will restrict the type of accepted values. Values in the collection will be checked to ensure that they match the annotated collection types. The following collection types are supported:</p> <ol> <li><code>collections.abc.Sequence</code> (<code>typing.Sequence</code> on Python &lt; 3.9)</li> <li><code>tuple</code> (<code>typing.Tuple</code> on Python &lt; 3.9)</li> <li><code>list</code> (<code>typing.List</code> on Python &lt; 3.9)</li> <li><code>set</code> (<code>typing.Set</code> on Python &lt; 3.9)</li> </ol> <p>There are a few different ways to use these types, each resulting in different validation conditions. The simplest case is a plain (possibly empty) collection of a single type::</p> <pre><code>&gt;&gt;&gt; from typing import List, Sequence, Set, Tuple\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Sequence[int]\n...     y: Tuple[str]\n...     z: Set[float]\n...     w: List[int]\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = [1, 2]\n&gt;&gt;&gt; a.y = (\"1\", \"2\")\n&gt;&gt;&gt; a.z = {1.0, 2.0}\n&gt;&gt;&gt; a.w = [1, 2]\n&gt;&gt;&gt; a\nA(x=[1, 2], y=('1', '2'), z={1.0, 2.0}, w=[1, 2])\n\n&gt;&gt;&gt; a.x = [1, \"2\"]\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '2'\n\n&gt;&gt;&gt; a.x = (1, 2)      # `Sequence` accepts any sequence type\n\n&gt;&gt;&gt; # `Tuple` only accepts tuples\n&gt;&gt;&gt; a.y = [\"1\", \"2\"]  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: error setting `y`: invalid value for type 'typing.Tuple[str]':\n['1', '2']\n</code></pre> <p>The collection length can be controlled by the arguments of the type annotation. Note, however, that <code>typing.Sequence/typing.List/typing.Set</code> do not accept multiple arguments, and so, cannot be used if collection length has to be specified. On Python &lt; 3.9, only <code>typing.Tuple</code> can be used for controlling collection lengths.</p> <p>To specify that a collection must be non-empty, use ellipsis (<code>...</code>) as the second argument of the type::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Tuple[int, ...]\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = tuple()  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: expected non-empty collection for type\n'typing.Tuple[int, ...]'\n</code></pre> <p>Collections can also be restricted to be of a fixed length::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Tuple[int, str]\n...     y: Tuple[int, int, int]\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = (1, 1)\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'str'&gt;': 1\n\n&gt;&gt;&gt; a.y = (1, 1)  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: error setting `y`: invalid value for type\n'typing.Tuple[int, int, int]': (1, 1): expected exactly '3' elements\n</code></pre> <p>Literals <code>typing.Literal</code> can be used to specify that an attribute takes one of a fixed set of values::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Literal[0, 1, \"2\"]\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = 0\n&gt;&gt;&gt; a.x = \"2\"\n&gt;&gt;&gt; a.x = \"1\"  # doctest: +IGNORE_EXCEPTION_DETAIL\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type\n'typing.Literal[0, 1, '2']': '1'\n</code></pre> <p>Type annotations can be nested; for instance, <code>Sequence[Literal[0, 1, 2], Literal[0, 1, 2]]</code> represents a sequence of length 2, where each element is either 0, 1, or 2.</p> <p>A fixed set of attribute values can also be specified by adding a <code>__choices__</code> attribute to the argument type, containing a collection of choices::</p> <pre><code>&gt;&gt;&gt; class T(int):\n...     __choices__ = (1, 2)\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: T\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = 1\n&gt;&gt;&gt; a.x = 3  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'T'&gt;': 3:\nexpected one of: (1, 2)\n</code></pre> <p>Note that choices specified in this way are not type-checked to ensure that they match the argument type; in the above example, <code>__choices__</code> could be set to <code>(1, \"2\")</code>.</p> <p>Self <code>Corgy</code> classes can have attributes of their own type, annotated using <code>typing.Self</code>.</p> <pre><code>&gt;&gt;&gt; if sys.version_info &gt;= (3, 11):\n...     from typing import Self\n... else:\n...     from typing_extensions import Self\n\n&gt;&gt;&gt; class C(Corgy):\n...     x: int\n...     c: Self\n\n&gt;&gt;&gt; c = C(x=1)\n&gt;&gt;&gt; c.c = C(x=2)\n&gt;&gt;&gt; c\nC(x=1, c=C(x=2))\n\n&gt;&gt;&gt; class D(C):\n...     ...\n\n&gt;&gt;&gt; c.c = D(x=3)  # doctest: +NORMALIZE_WHITESPACE\nTraceback (most recent call last):\n    ...\nValueError: error setting `c`: invalid value for type 'Self (bound to\n&lt;class 'C'&gt;)': D(x=3)\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.add_args_to_parser","title":"add_args_to_parser  <code>classmethod</code>","text":"<pre><code>add_args_to_parser(parser, name_prefix='', flatten_subgrps=False, defaults=None)\n</code></pre> <p>Add the class' <code>Corgy</code> attributes to the given parser.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>_ActionsContainer</code> <p>Argument parser/group to which the attributes will be added.</p> required <code>name_prefix</code> <code>str</code> <p>Prefix for argument names. Arguments will be named <code>--&lt;name-prefix&gt;:&lt;attr-name&gt;</code>. If custom flags are present, <code>--&lt;name-prefix&gt;:&lt;flag&gt;</code> will be used instead (one for each flag).</p> <code>''</code> <code>flatten_subgrps</code> <code>bool</code> <p>Whether to add sub-groups to the main parser instead of creating argument groups. Note: sub-sub-groups are always added with this argument set to <code>True</code>, since <code>argparse</code> in unable to properly display nested group arguments.</p> <code>False</code> <code>defaults</code> <code>Optional[Mapping[str, Any]]</code> <p>Optional mapping with default values for arguments. Any value specified here will override default values specified in the class. Values for groups can be specified either as <code>Corgy</code> instances, or as individual values using the same syntax as for <code>Corgy.from_dict</code>.</p> <code>None</code> <p>Type annotations control how attributes are added to the parser. A number of special annotations are parsed and stripped from attribute types to determine the parameters for calling <code>ArgumentParser.add_argument</code>. These special annotations are described below.</p> <p>Note: <code>add_args_to_parser</code> cannot be used if the type annotation for any attribute of the class includes <code>Self</code>, unless a custom parser is defined for such attributes. See docs for <code>corgyparser</code> on how to define custom parsers.</p> <p>Annotated <code>typing.Annotated</code> can be used to add a help message for the argument::</p> <pre><code>&gt;&gt;&gt; import argparse\n&gt;&gt;&gt; from argparse import ArgumentParser\n&gt;&gt;&gt; from corgy import CorgyHelpFormatter\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Annotated[int, \"help for x\"]\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --x int  help for x (optional)\n</code></pre> <p>This annotation can also be used to modify the parser flags for the argument. By default, the attribute name is used, prefixed with <code>--</code>, and with <code>_</code> replaced by <code>-</code>. If the custom flag does not have a leading <code>-</code>, a positional argument will be created::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Annotated[int, \"help for x\", [\"-x\", \"--ex\"]]\n...     y: Annotated[int, \"help for y\", [\"y\"]]\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\npositional arguments:\n  y int        help for y\n&lt;BLANKLINE&gt;\noptions:\n  -x/--ex int  help for x (optional)\n</code></pre> <p><code>Annotated</code> can accept multiple arguments, but only the first three are used by <code>Corgy</code>. The first argument is the attribute type, the second is the help message (which must be a string), and the third is a sequence of flags.</p> <p>Required/NotRequired Every corgy attribute is either required or not required. The default status depends on the class parameter <code>corgy_required_by_default</code> (<code>False</code> by default). Attributes can also be explicitly marked as required or not required, and will control whether the argument will be added with <code>required=True</code>::</p> <pre><code>&gt;&gt;&gt; from corgy import Required, NotRequired\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Required[int]\n...     y: NotRequired[int]\n...     z: int\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --x int  (required)\n  --y int  (optional)\n  --z int  (optional)\n</code></pre> <p>Attributes which are not required, and don't have a default value are added with <code>default=argparse.SUPPRESS</code>, and so will not be in the parsed namespace::</p> <pre><code>&gt;&gt;&gt; parser.parse_args([\"--x\", \"1\", \"--y\", \"2\"])\nNamespace(x=1, y=2)\n</code></pre> <p>Optional Attributes marked with <code>typing.Optional</code> are allowed to be <code>None</code>. The arguments for these attributes can be passed with no values (i.e. <code>--x</code> instead of <code>--x=1</code> or <code>--x 1</code>) to indicate that the value should be <code>None</code>.</p> <p>Note: Attributes with default values are also \"optional\" in the sense that they can be omitted from the command line. However, they are not the same as attributes marked with <code>Optional</code>, since the former are not allowed to be <code>None</code>. Furthermore, <code>Required</code> <code>Optional</code> attributes without default values will need to be passed on the command line (possibly with no values).</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Required[Optional[int]]\n\n&gt;&gt;&gt; parser = ArgumentParser()\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.parse_args([\"--x\"])\nNamespace(x=None)\n</code></pre> <p>Boolean <code>bool</code> types (when not in a collection) are converted to a pair of options::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     arg: bool\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --arg/--no-arg\n</code></pre> <p>Collection Collection types are added to the parser by setting <code>nargs</code>. The value for <code>nargs</code> is determined by the collection type. Plain collections, such as <code>Sequence[int]</code>, will be added with <code>nargs=*</code>; Non-empty collections, such as <code>Sequence[int, ...]</code>, will be added with <code>nargs=+</code>; Finally, fixed-length collections, such as <code>Sequence[int, int, int]</code>, will be added with <code>nargs</code> set to the length of the collection.</p> <p>In all cases, collection types can only be added to a parser if they are single type. Heterogenous collections, such as <code>Sequence[int, str]</code> cannot be added, and will raise <code>ValueError</code>. Untyped collections (e.g., <code>x: Sequence</code>), also cannot be added.</p> <p>Arguments for optional collections will also accept no values to indicate <code>None</code>. Due to this, it is not possible to parse an empty collection for an optional collection argument::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Optional[Sequence[int]]\n...     y: Sequence[int]\n\n&gt;&gt;&gt; parser = ArgumentParser()\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.parse_args([\"--x\", \"--y\"])\nNamespace(x=None, y=[])\n</code></pre> <p>Literal For <code>Literal</code> types, the provided values are passed to the <code>choices</code> argument of <code>ArgumentParser.add_argument</code>. All values must be of the same type, which will be inferred from the type of the first value. If the first value has a <code>__bases__</code> attribute, the type will be inferred as the first base type, and all other choices must be subclasses of that type::</p> <pre><code>&gt;&gt;&gt; class T: ...\n&gt;&gt;&gt; class T1(T): ...\n&gt;&gt;&gt; class T2(T): ...\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: Literal[T1, T2]\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --x T  ({T1/T2} optional)\n</code></pre> <p>For types which specify choices by defining <code>__choices__</code>, the values are passed to the <code>choices</code> argument as with <code>Literal</code>, but no type inference is performed, and the base attribute type will be used as the argument type.</p> <p>Single-value Literals A special case for <code>Literal</code> types is when there is only one choice. In this case, the argument is added as a <code>store_const</code> action, with the value as the <code>const</code> argument. A further special case is when the choice is <code>True/False</code>, in which case the action is <code>store_true</code>/<code>store_false</code> respectively::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Literal[True]\n...     y: Literal[False]\n...     z: Literal[42]\n\n&gt;&gt;&gt; parser = ArgumentParser()\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.parse_args([\"--x\"])  # Note that `y` and `z` are absent\nNamespace(x=True)\n&gt;&gt;&gt; parser.parse_args([\"--y\"])\nNamespace(y=False)\n&gt;&gt;&gt; parser.parse_args([\"--z\"])\nNamespace(z=42)\n</code></pre> <p>Note: This special case only applies to <code>Literal</code> types, and not types which define <code>__choices__</code>.</p> <p>Corgy Attributes which are themselves <code>Corgy</code> types are treated as argument groups. Group arguments are added to the command line parser with the group attribute name prefixed. Note that groups will ignore any custom flags when computing the prefix; elements within the group will use custom flags, but because they are prefixed with <code>--</code>, they will not be positional.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; class G(Corgy):\n...     x: int = 0\n...     y: float\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     g: G\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --x int      (optional)\n&lt;BLANKLINE&gt;\ng:\n  --g:x int    (default: 0)\n  --g:y float  (optional)\n</code></pre> <p>Custom parsers</p> <p>Attributes for which a custom parser is defined using <code>@corgyparser</code> will be added with a custom action that will call the parser. Refer to the documentation for <code>corgyparser</code> for details.</p> <p>Metavar</p> <p>This function will not explicitly pass a value for the <code>metavar</code> argument of <code>ArgumentParser.add_argument</code>, unless an attribute's type defines <code>__metavar__</code>, in which case, it will be passed as is. To change the metavar for attributes with custom parsers, set the <code>metavar</code> argument of <code>corgyparser</code>.</p>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.as_dict","title":"as_dict","text":"<pre><code>as_dict(recursive=True, flatten=False)\n</code></pre> <p>Return the object as a dictionary.</p> <p>The returned dictionary maps attribute names to their values. Unset attributes are omitted, unless they have default values.</p> <p>Parameters:</p> Name Type Description Default <code>recursive</code> <code>bool</code> <p>whether to recursively call <code>as_dict</code> on attributes which are <code>Corgy</code> instances. Otherwise, they are returned as is.</p> <code>True</code> <code>flatten</code> <code>bool</code> <p>whether to flatten group arguments into <code>:</code> separated strings. Only takes effect if <code>recursive</code> is <code>True</code>.</p> <code>False</code> <p>Examples::</p> <pre><code>&gt;&gt;&gt; class G(Corgy):\n...     x: int\n\n&gt;&gt;&gt; g = G(x=1)\n&gt;&gt;&gt; g.as_dict()\n{'x': 1}\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: str\n...     g: G\n\n&gt;&gt;&gt; a = A(x=\"one\", g=g)\n&gt;&gt;&gt; a.as_dict(recursive=False)\n{'x': 'one', 'g': G(x=1)}\n&gt;&gt;&gt; a.as_dict()\n{'x': 'one', 'g': {'x': 1}}\n&gt;&gt;&gt; a.as_dict(flatten=True)\n{'x': 'one', 'g:x': 1}\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.attrs","title":"attrs  <code>classmethod</code>","text":"<pre><code>attrs()\n</code></pre> <p>Return a dictionary mapping attributes of the class to their types.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: Annotated[int, \"x\"]\n...     y: Sequence[str]\n\n&gt;&gt;&gt; A.attrs()\n{'x': &lt;class 'int'&gt;, 'y': typing.Sequence[str]}\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.freeze","title":"freeze","text":"<pre><code>freeze()\n</code></pre> <p>Freeze the object, preventing any further changes to attributes.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: int\n\n&gt;&gt;&gt; a = A(x=1, y=2)\n&gt;&gt;&gt; a.x = 2\n&gt;&gt;&gt; a.freeze()\n&gt;&gt;&gt; a.x = 3\nTraceback (most recent call last):\n    ...\nTypeError: cannot set `x`: object is frozen\n&gt;&gt;&gt; del a.y\nTraceback (most recent call last):\n    ...\nTypeError: cannot delete `y`: object is frozen\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.from_dict","title":"from_dict  <code>classmethod</code>","text":"<pre><code>from_dict(d, try_cast=False)\n</code></pre> <p>Return a new instance of the class using a dictionary.</p> <p>This is roughly equivalent to <code>cls(**d)</code>, with the main exception being that groups can be specified as dictionaries themselves, and will be processed recursively.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Mapping[str, Any]</code> <p>Dictionary to create the instance from.</p> required <code>try_cast</code> <code>bool</code> <p>Whether to try and cast values which don't match attribute types.</p> <code>False</code> <p>Example::</p> <pre><code>&gt;&gt;&gt; class G(Corgy):\n...     x: int\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: str\n...     g: G\n\n&gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g\": G(x=1)})\nA(x='one', g=G(x=1))\n&gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g\": {\"x\": 1}})\nA(x='one', g=G(x=1))\n&gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g\": {\"x\": \"1\"}}, try_cast=True)\nA(x='one', g=G(x=1))\n&gt;&gt;&gt; G.from_dict({\"x\": \"1\"})\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n</code></pre> <p>Group attributes can also be passed directly in the dictionary by prefixing their names with the group name and a colon::</p> <pre><code>&gt;&gt;&gt; A.from_dict({\"x\": \"one\", \"g:x\": 1})\nA(x='one', g=G(x=1))\n\n&gt;&gt;&gt; class B(Corgy):\n...     x: float\n...     a: A\n\n&gt;&gt;&gt; B.from_dict({\"x\": 1.1, \"a:x\": \"one\", \"a:g:x\": 1})\nB(x=1.1, a=A(x='one', g=G(x=1)))\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.is_attr_set","title":"is_attr_set","text":"<pre><code>is_attr_set(attr_name)\n</code></pre> <p>Check if a <code>Corgy</code> attribute is set.</p> <p>Parameters:</p> Name Type Description Default <code>attr_name</code> <code>str</code> <p>Name of the attribute to check.</p> required <p>Raises:</p> Type Description <code>AttributeError</code> <p>if the attribute is not a <code>Corgy</code> attribute.</p>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.load_dict","title":"load_dict","text":"<pre><code>load_dict(d, try_cast=False, strict=False)\n</code></pre> <p>Load a dictionary into an instance of the class.</p> <p>Previous attributes are overwritten. Sub-dictionaries will be parsed recursively if the corresponding attribute already exists, else will be parsed using <code>from_dict</code>. As with <code>from_dict</code>, items in the dictionary without corresponding attributes are ignored.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>Dict[str, Any]</code> <p>Dictionary to load.</p> required <code>try_cast</code> <code>bool</code> <p>Whether to try and cast values which don't match attribute types.</p> <code>False</code> <code>strict</code> <code>bool</code> <p>If <code>True</code>, attributes with existing values that are not in the dictionary will be unset.</p> <code>False</code> <p>Example::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: str\n&gt;&gt;&gt; a = A(x=1)\n&gt;&gt;&gt; _i = id(a)\n&gt;&gt;&gt; a.load_dict({\"y\": \"two\"})\n&gt;&gt;&gt; a\nA(x=1, y='two')\n&gt;&gt;&gt; _i == id(a)\nTrue\n&gt;&gt;&gt; a.load_dict({\"y\": \"three\"}, strict=True)\n&gt;&gt;&gt; a\nA(y='three')\n&gt;&gt;&gt; _i == id(a)\nTrue\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.load_dict({\"x\": \"1\"})\nTraceback (most recent call last):\n    ...\nValueError: error setting `x`: invalid value for type '&lt;class 'int'&gt;': '1'\n&gt;&gt;&gt; a.load_dict({\"x\": \"1\"}, try_cast=True)\n&gt;&gt;&gt; a\nA(x=1)\n</code></pre>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.parse_from_cmdline","title":"parse_from_cmdline  <code>classmethod</code>","text":"<pre><code>parse_from_cmdline(parser=None, defaults=None, **parser_args)\n</code></pre> <p>Return an instance of the class parsed from command line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>Optional[ArgumentParser]</code> <p>An instance of <code>argparse.ArgumentParser</code> or <code>None</code>. If <code>None</code>, a new instance is created.</p> <code>None</code> <code>defaults</code> <code>Optional[Mapping[str, Any]]</code> <p>A dictionary of default values for the attributes, passed to <code>add_args_to_parser</code>. Refer to the docs for <code>add_args_to_parser</code> for more details.</p> <code>None</code> <code>parser_args</code> <p>Arguments to be passed to <code>argparse.ArgumentParser()</code>. Ignored if <code>parser</code> is not None.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ArgumentTypeError</code> <p>Error parsing command line arguments.</p>"},{"location":"usage/corgy.html#corgy._corgy.Corgy.parse_from_toml","title":"parse_from_toml  <code>classmethod</code>","text":"<pre><code>parse_from_toml(toml_file, defaults=None)\n</code></pre> <p>Parse an object of the class from a toml file.</p> <p>Parameters:</p> Name Type Description Default <code>toml_file</code> <code>IO[bytes]</code> <p>A file-like object containing the class attributes in toml.</p> required <code>defaults</code> <code>Optional[Mapping[str, Any]]</code> <p>A dictionary of default values, overriding any values specified in the class.</p> <code>None</code> <p>Raises:</p> Type Description <code>TOMLDecodeError</code> <p>Error parsing the toml file.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; class G(Corgy):\n...     x: int\n...     y: Sequence[int]\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: str\n...     g: G\n\n&gt;&gt;&gt; from io import BytesIO\n&gt;&gt;&gt; f = BytesIO(b'''\n...     x = 'one'\n...     [g]\n...     x = 1\n...     y = [1, 2, 3]\n... ''')\n\n&gt;&gt;&gt; A.parse_from_toml(f)  # doctest: +SKIP\nA(x='one', g=G(x=1, y=[1, 2, 3]))\n</code></pre>"},{"location":"usage/corgy.html#corgy.corgyparser","title":"corgy.corgyparser","text":"<pre><code>corgy.corgyparser(*var_names, metavar=None, nargs=None)\n</code></pre> <p>Decorate a function as a custom parser for one or more attributes.</p> <p>To use a custom function for parsing a <code>Corgy</code> attribute, use this decorator. Parsing functions must be static, and should only accept a single argument. Decorating the function with <code>@staticmethod</code> is optional, but prevents type errors. <code>@corgyparser</code> must be the final decorator in the decorator chain.</p> <p>Parameters:</p> Name Type Description Default <code>var_names</code> <code>str</code> <p>The attributes associated with the decorated parser.</p> <code>()</code> <code>metavar</code> <code>Optional[str]</code> <p>Keyword only argument to set the metavar when adding the associated attribute(s) to an <code>ArgumentParser</code> instance.</p> <code>None</code> <code>nargs</code> <code>Union[None, Literal['*', '+'], int]</code> <p>Keyword only argument to set the number of arguments to be used for the associated attribute(s). Must be <code>None</code>, <code>'*'</code>, <code>'+'</code>, or a positive number. This value is passed as the <code>nargs</code> argument to <code>ArgumentParser.add_argument</code>, and controls the number of arguments that will be read from the command line, and passed to the parsing function. For all values other than <code>None</code>, the parsing function will receive a list of strings.</p> <code>None</code> <p>Example::</p> <pre><code>&gt;&gt;&gt; import argparse\n&gt;&gt;&gt; from argparse import ArgumentParser\n&gt;&gt;&gt; from typing import Tuple\n&gt;&gt;&gt; from corgy import Corgy, CorgyHelpFormatter, corgyparser\n\n&gt;&gt;&gt; class A(Corgy):\n...     time: Tuple[int, int, int]\n...     @corgyparser(\"time\", metavar=\"int:int:int\")\n...     @staticmethod\n...     def parse_time(s):\n...         return tuple(map(int, s.split(\":\")))\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.parse_args([\"--time\", \"1:2:3\"])\nNamespace(time=(1, 2, 3))\n</code></pre> <p>Multiple arguments can be passed to the decorator, and will all be associated with the same parser::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: int\n...     @corgyparser(\"x\", \"y\")\n...     @staticmethod\n...     def parse_x_y(s):\n...         return int(s)\n</code></pre> <p>The <code>@corgyparser</code> decorator can also be chained to use the same parser for multiple arguments::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: int\n...     @corgyparser(\"x\")\n...     @corgyparser(\"y\")\n...     @staticmethod\n...     def parse_x_y(s):\n...         return int(s)\n</code></pre> <p>Note: when chaining, the outer-most non-<code>None</code> value of <code>metavar</code> will be used.</p> <p>Custom parsers can control the number of arguments they receive, independent of the argument type::</p> <pre><code>&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     @corgyparser(\"x\", nargs=3)\n...     @staticmethod\n...     def parse_x(s):\n...         # `s` will be a list of 3 strings.\n...         return sum(map(int, s))\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n\n&gt;&gt;&gt; A.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.parse_args([\"--x\", \"1\", \"2\", \"3\"])\nNamespace(x=6)\n</code></pre> <p>When chaining, <code>nargs</code> must be the same for all decorators, otherwise <code>TypeError</code> is raised.</p>"},{"location":"usage/corgy.html#corgy.corgychecker","title":"corgy.corgychecker","text":"<pre><code>corgy.corgychecker(*var_names)\n</code></pre> <p>Decorate a function as a custom checker for one or more attributes.</p> <p>To use a custom function for checking the value of a <code>Corgy</code> attribute, use this decorator. Checking functions must be static, and should only accept a single argument, the value to be checked. They should raise <code>ValueError</code> to indicate value mismatch. Decorating the function with <code>@staticmethod</code> is optional, but prevents type errors. <code>@corgychecker</code> must be the final decorator in the decorator chain.</p> <p>Custom checkers are called after type checking, so the values passed to them will be of type corresponding to one of the assigned attributes.</p> <p>Parameters:</p> Name Type Description Default <code>var_names</code> <code>str</code> <p>The attributes associated with the decorated checker.</p> <code>()</code> <p>Example::</p> <pre><code>&gt;&gt;&gt; from corgy import Corgy, corgychecker\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     @corgychecker(\"x\")\n...     @staticmethod\n...     def check_x(val):\n...         if val % 2:\n...             raise ValueError(f\"'{val}' is not even\")\n\n&gt;&gt;&gt; a = A()\n&gt;&gt;&gt; a.x = 2\n&gt;&gt;&gt; a.x = 3\nTraceback (most recent call last):\n   ...\nValueError: error setting `x`: '3' is not even\n</code></pre> <p>Multiple attributes can use the same checker, either by chaining <code>corgychecker</code>, or by passing all attribute names directly::</p> <pre><code>&gt;&gt;&gt; from typing import Sequence\n\n&gt;&gt;&gt; class A(Corgy):\n...     x: int\n...     y: float\n...     z: str\n...     w: Sequence[int]\n...     @corgychecker(\"x\")\n...     @corgychecker(\"y\")\n...     def check_num(val):\n...         if val &lt; 0:\n...             raise ValueError(\"should be non-negative\")\n...     @corgychecker(\"z\", \"w\")\n...     def check_seq(val):\n...         if len(val) &gt; 10:\n...             raise ValueError(\"too long\")\n</code></pre>"},{"location":"usage/corgy.html#corgy.CorgyHelpFormatter","title":"corgy.CorgyHelpFormatter","text":"<p>         Bases: <code>HelpFormatter</code></p> <p>Formatter class for <code>argparse</code> with a cleaner layout, and support for colors.</p> <p><code>Corgy.parse_from_cmdline</code> uses this formatter by default, unless a different <code>formatter_class</code> argument is provided. <code>CorgyHelpFormatter</code> can also be used independently of <code>Corgy</code>. Simply pass it as the <code>formatter_class</code> argument to <code>argparse.ArgumentParser()</code>::</p> <pre><code>&gt;&gt;&gt; import argparse\n&gt;&gt;&gt; from argparse import ArgumentParser\n&gt;&gt;&gt; from corgy import CorgyHelpFormatter\n\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     usage=argparse.SUPPRESS,\n... )\n&gt;&gt;&gt; _ = parser.add_argument(\"--x\", type=int, required=True)\n&gt;&gt;&gt; _ = parser.add_argument(\"--y\", type=str, nargs=\"*\", required=True)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  -h/--help      show this help message and exit\n  --x int        (required)\n  --y [str ...]  (required)\n</code></pre> <p>To configure <code>CorgyHelpFormatter</code>, you can set a number of attributes on the class. Note that you do not need to create an instance of the class; that is done by the parser itself. The following public attributes are available:</p> <p>Color-related attributes:</p> <ul> <li> <p><code>enable_colors</code>: If <code>None</code> (the default), colors are enabled if the <code>crayons</code>   package is available, and the output is a tty. To explicitly enable or disable   colors, set to <code>True</code> or <code>False</code>.</p> </li> <li> <p><code>color_&lt;choices/keywords/metavars/defaults/options&gt;</code>: These attributes control   the colors used for various parts of the output (see below for reference).   Available colors are <code>red</code>, <code>green</code>, <code>yellow</code>, <code>blue</code>, <code>black</code>, <code>magenta</code>, <code>cyan</code>,   and <code>white</code>. Specifying the name in all caps will make the color bold. You can   also use the special value <code>BOLD</code> to make the output bold without changing the   color. The default value are <code>blue</code> for choices, <code>green</code> for keywords, <code>RED</code> for   metavars, <code>YELLOW</code> for defaults, and <code>BOLD</code> for options. Format::</p> <pre><code> -a/--arg str       help for arg ({'a'/'b'/'c'} default: 'a')\n   |      |                          |            |      |\n options  metavars                 choices      keywords defaults\n</code></pre> </li> </ul> <p>Layout-related attributes:</p> <ul> <li> <p><code>output_width</code>: The number of columns used for the output. If <code>None</code> (the   default), the current terminal width is used.</p> </li> <li> <p><code>max_help_position</code>: How far to the right (from the start), the help string can   start from. If <code>None</code>, there is no limit. The default is to use half the current   terminal width.</p> </li> </ul> <p>Marker-related attributes:</p> <ul> <li> <p><code>marker_extras_&lt;begin/end&gt;</code>: The strings used to enclose the extra help text   (choices, default values etc.). The defaults are <code>(</code> and <code>)</code>.</p> </li> <li> <p><code>marker_choices_&lt;begin/end&gt;</code>: The strings used to enclose the list of choices for   an argument. The defaults are <code>{</code> and <code>}</code>.</p> </li> <li> <p><code>marker_choices_sep</code>: The string used to separate individual choices in the choice   list. The default is <code>/</code>.</p> </li> </ul> <p>Misc. attributes:</p> <ul> <li><code>show_full_help</code>: Whether to show the full help, including choices, indicators for   required arguments, and the usage string. The default is <code>True</code>.</li> </ul> <p>Formatting of individual arguments can be customized with magic attributes defined on the argument type. The following attributes are recognized:</p> <ul> <li><code>__metavar__</code>: This can be set to a string on the argument type to override the   default metavar. Example::<pre><code> &gt;&gt;&gt; class T:\n ...     __metavar__ = \"METAVAR\"\n\n &gt;&gt;&gt; parser = ArgumentParser(\n ...     formatter_class=CorgyHelpFormatter,\n ...     add_help=False,\n ...     usage=argparse.SUPPRESS,\n ... )\n &gt;&gt;&gt; _ = parser.add_argument(\"--arg\", type=T)\n &gt;&gt;&gt; parser.print_help()\n options:\n   --arg METAVAR  (default: None)\n</code></pre> </li> </ul>"},{"location":"usage/corgy.html#corgy._helpfmt.CorgyHelpFormatter.using_colors","title":"using_colors  <code>property</code>","text":"<pre><code>using_colors: bool\n</code></pre> <p>Whether colors are enabled.</p>"},{"location":"usage/corgy.html#corgy._helpfmt.CorgyHelpFormatter.FullHelpAction","title":"FullHelpAction","text":"<p>         Bases: <code>Action</code></p> <p><code>argparse.Action</code> that displays the full help, and exits.</p>"},{"location":"usage/corgy.html#corgy._helpfmt.CorgyHelpFormatter.ShortHelpAction","title":"ShortHelpAction","text":"<p>         Bases: <code>Action</code></p> <p><code>argparse.Action</code> that displays the short help, and exits.</p>"},{"location":"usage/corgy.html#corgy._helpfmt.CorgyHelpFormatter.add_short_full_helps","title":"add_short_full_helps  <code>classmethod</code>","text":"<pre><code>add_short_full_helps(parser, short_help_flags=('-h', '--help'), full_help_flags=('--helpfull'), short_help_msg='show help message and exit', full_help_msg='show full help message and exit')\n</code></pre> <p>Add arguments for displaying the short or full help.</p> <p>The parser must be created with <code>add_help=False</code> to prevent a clash with the added arguments.</p> <p>Parameters:</p> Name Type Description Default <code>parser</code> <code>ArgumentParser</code> <p><code>ArgumentParser</code> instance to add the arguments to.</p> required <code>short_help_flags</code> <code>Sequence[str]</code> <p>Sequence of argument strings for the short help option. Default is <code>(\"-h\", \"--help\")</code>.</p> <code>('-h', '--help')</code> <code>full_help_flags</code> <code>Sequence[str]</code> <p>Sequence of argument strings for the full help option. Default is <code>(\"--helpfull\")</code>.</p> <code>('--helpfull')</code> <code>short_help_msg</code> <code>str</code> <p>String to describe the short help option. Default is <code>\"show help message and exit\"</code>.</p> <code>'show help message and exit'</code> <code>full_help_msg</code> <code>str</code> <p>String to describe the full help option. Default is <code>\"show full help message and exit\"</code>.</p> <code>'show full help message and exit'</code> <p>Example::</p> <pre><code>&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n&gt;&gt;&gt; CorgyHelpFormatter.add_short_full_helps(parser)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  -h/--help   show help message and exit\n  --helpfull  show full help message and exit\n</code></pre>"},{"location":"usage/corgy.types.html","title":"corgy.types","text":"<p>Types for use with <code>corgy</code> (or standalone with <code>argparse</code>).</p> <p>An object of the types defined in this module can be created by calling the respective type class with a single string argument. <code>ValueError</code> is raised if the argument can not be converted to the desired type.</p> <p>Examples::</p> <pre><code>&gt;&gt;&gt; from corgy.types import KeyValuePairs\n&gt;&gt;&gt; StrIntMapType = KeyValuePairs[str, int]\n&gt;&gt;&gt; str_int_map = StrIntMapType(\"a=1,b=2\")\n&gt;&gt;&gt; print(str_int_map)\n{'a': 1, 'b': 2}\n\n&gt;&gt;&gt; class A: ...\n&gt;&gt;&gt; class B(A): ...\n&gt;&gt;&gt; class C(A): ...\n\n&gt;&gt;&gt; from corgy.types import SubClass\n&gt;&gt;&gt; ASubClsType = SubClass[A]\n&gt;&gt;&gt; a_subcls = ASubClsType(\"B\")\n&gt;&gt;&gt; a_subcls_obj = a_subcls()\n&gt;&gt;&gt; a_subcls_obj  # doctest: +SKIP\n&lt;B object at 0x106cd93d0&gt;\n\n&gt;&gt;&gt; import argparse\n&gt;&gt;&gt; from argparse import ArgumentParser\n&gt;&gt;&gt; from corgy import CorgyHelpFormatter\n&gt;&gt;&gt; from corgy.types import InputFile\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n&gt;&gt;&gt; _ = parser.add_argument(\"--f\", type=InputFile)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --f file  (default: None)\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types.KeyValuePairs","title":"corgy.types.KeyValuePairs","text":"<p>         Bases: <code>dict</code>, <code>Generic[_KT, _VT]</code></p> <p>Dictionary sub-class that is initialized from a string of key-value pairs.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; from corgy.types import KeyValuePairs\n\n&gt;&gt;&gt; MapType = KeyValuePairs[str, int]\n&gt;&gt;&gt; print(MapType(\"a=1,b=2\"))\n{'a': 1, 'b': 2}\n</code></pre> <p>This class supports the class indexing syntax to specify the types for keys and values. <code>KeyValuePairs[KT, VT]</code> returns a new <code>KeyValuePairs</code> type where the key and value types are <code>KT</code> and <code>VT</code>, respectively. Using the class directly is equivalent to using <code>KeyValuePairs[str, str]</code>.</p> <p>When called, the class expects a single string argument, with comma-separated <code>key=value</code> pairs (see below for how to change the separators). The string is parsed, and a dictionary is created with the keys and values cast to their respective types. <code>ValueError</code> is raised if this fails. This class is useful for parsing dictionaries from command-line arguments.</p> <p>By default, the class expects a string of the form <code>key1=value1,key2=value2,...</code>. This can be changed by setting the following class attributes:</p> <ul> <li> <p>sequence_separator: The string that separates individual key-value pairs. The     default is <code>,</code>.</p> </li> <li> <p>item_separator: The string that separates keys and values. The default is <code>=</code>.</p> </li> </ul> <p>Note that types returned by the <code>KeyValuePairs[...]</code> syntax are cached using the key and value types::</p> <pre><code>&gt;&gt;&gt; MapType = KeyValuePairs[str, int]\n&gt;&gt;&gt; MapType.sequence_separator = \";\"\n&gt;&gt;&gt; MapType2 = KeyValuePairs[str, int]  # same as `MapType`\n&gt;&gt;&gt; MapType2.sequence_separator\n';'\n&gt;&gt;&gt; MapType2.sequence_separator = \",\"\n</code></pre> <p><code>KeyValuePairs</code> instances can also be initialized with a dictionary. However, note that the dictionary is not type-checked and is used as-is.</p>"},{"location":"usage/corgy.types.html#corgy.types.SubClass","title":"corgy.types.SubClass","text":"<p>         Bases: <code>Generic[_T]</code></p> <p>Type representing a sub-class of a given class.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; from corgy.types import SubClass\n\n&gt;&gt;&gt; class Base: ...\n&gt;&gt;&gt; class Sub1(Base): ...\n&gt;&gt;&gt; class Sub2(Base): ...\n\n&gt;&gt;&gt; BaseSubType = SubClass[Base]   # type for a sub-class of `Base`\n&gt;&gt;&gt; BaseSub = BaseSubType(\"Sub1\")  # sub-class of `Base` named `Sub1`\n&gt;&gt;&gt; base_sub = BaseSub()           # instance of a sub-class of `Base`\n&gt;&gt;&gt; base_sub  # doctest: +SKIP\n&lt;Sub1 object at 0x100ea40a0&gt;\n</code></pre> <p>This class cannot be called directly. It first needs to be associated with a base class, using the <code>SubClass[Base]</code> syntax. This returns a new <code>SubClass</code> type, which is associated with <code>Base</code>. The returned type is callable, and accepts the name of a sub-class of <code>Base</code>. So, <code>SubClass[Base](\"Sub1\")</code> returns a <code>SubClass</code> type instance corresponding to the sub-class <code>Sub1</code> of <code>Base</code>. Finally, the <code>SubClass</code> instance can be called to create an instance of the sub-class, e.g., <code>SubClass[Base](\"Sub1\")()</code>.</p> <p>This class is useful for creating objects of a generic class, where the concrete class is determined at runtime, e.g, by a command-line argument::</p> <pre><code>&gt;&gt;&gt; from argparse import ArgumentParser\n\n&gt;&gt;&gt; parser = ArgumentParser()\n&gt;&gt;&gt; _ = parser.add_argument(\"--base-subcls\", type=SubClass[Base])\n\n&gt;&gt;&gt; args = parser.parse_args([\"--base-subcls\", \"Sub1\"])\n&gt;&gt;&gt; base_obj = args.base_subcls()  # an instance of a sub-class of `Base`\n</code></pre> <p>For further convenience when parsing command-line arguments, the class provides a <code>__choices__</code> property, which returns a tuple of all valid sub-classes, and can be passed as the <code>choices</code> argument to <code>ArgumentParser.add_argument</code>. Refer to the docstring of <code>__choices__</code> for more information.</p> <p>The behavior of sub-class type identification can be customized by setting class attributes (preferably on the type returned by the <code>[...]</code> syntax).</p> <ul> <li> <p><code>allow_base</code>: If <code>True</code>, the base class itself will be allowed as a valid     sub-class. The default is <code>False</code>. Example::</p> <pre><code>&gt;&gt;&gt; class Base: ...\n&gt;&gt;&gt; class Sub1(Base): ...\n&gt;&gt;&gt; class Sub2(Base): ...\n&gt;&gt;&gt; T = SubClass[Base]\n&gt;&gt;&gt; T.__choices__\n(SubClass[Base]('Sub1'), SubClass[Base]('Sub2'))\n&gt;&gt;&gt; T.allow_base = True\n&gt;&gt;&gt; T.__choices__\n(SubClass[Base]('Base'), SubClass[Base]('Sub1'), SubClass[Base]('Sub2'))\n</code></pre> </li> <li> <p><code>use_full_names</code>: If <code>True</code>, the name passed to the constructor needs to be the     full name of a sub-class, given by <code>cls.__module__ + \".\" + cls.__qualname__</code>. If     <code>False</code> (the default), the name needs to just be <code>cls.__name__</code>. This is useful     if the sub-classes are not uniquely identified by just their names.</p> </li> <li> <p><code>allow_indirect_subs</code>: If <code>True</code> (the default), indirect sub-classes, i.e.,     sub-classes of the base through another sub-class, are allowed. If <code>False</code>,     only direct sub-classes of the base are allowed. Example::</p> <pre><code>&gt;&gt;&gt; class Base: ...\n&gt;&gt;&gt; class Sub1(Base): ...\n&gt;&gt;&gt; class Sub2(Sub1): ...\n&gt;&gt;&gt; T = SubClass[Base]\n&gt;&gt;&gt; T.__choices__\n(SubClass[Base]('Sub1'), SubClass[Base]('Sub2'))\n&gt;&gt;&gt; T.allow_indirect_subs = False\n&gt;&gt;&gt; T.__choices__\n(SubClass[Base]('Sub1'),)\n</code></pre> </li> </ul> <p>Note that the types returned by the <code>SubClass[...]</code> syntax are cached using the base class type. So all instances of <code>SubClass[Base]</code> will return the same type, and any attributes set on the type will be shared between all instances.</p>"},{"location":"usage/corgy.types.html#corgy.types._subclass.SubClass.__choices__","title":"__choices__  <code>property</code> <code>classmethod</code>","text":"<pre><code>__choices__: Tuple[SubClass[_T], ...]\n</code></pre> <p>Return a tuple of <code>SubClass</code> instances for valid sub-classes of the base.</p> <p>Each item in the tuple is an instance of <code>SubClass</code>, and corresponds to a valid sub-class of the base-class associated with this type.</p>"},{"location":"usage/corgy.types.html#corgy.types._subclass.SubClass.which","title":"which  <code>property</code>","text":"<pre><code>which: Type[_T]\n</code></pre> <p>Return the class represented by the <code>SubClass</code> instance.</p>"},{"location":"usage/corgy.types.html#corgy.types._subclass.SubClass.__call__","title":"__call__","text":"<pre><code>__call__(*args, **kwargs)\n</code></pre> <p>Return an instance of the sub-class associated with this type.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; class Base: ...\n&gt;&gt;&gt; class Sub1(Base):\n...     def __init__(self, x):\n...         print(f\"initializing `Sub1` with 'x={x}'\")\n\n&gt;&gt;&gt; BaseSubType = SubClass[Base]\n&gt;&gt;&gt; BaseSub = BaseSubType(\"Sub1\")  # an instance of the `SubClass` type\n\n&gt;&gt;&gt; base_sub = BaseSub(1)\ninitializing `Sub1` with 'x=1'\n</code></pre>"},{"location":"usage/corgy.types.html#corgy.types.InitArgs","title":"corgy.types.InitArgs","text":"<p>         Bases: <code>Corgy</code>, <code>Generic[_T]</code></p> <p>Corgy wrapper around arguments of a class's <code>__init__</code>.</p> <p>Example::</p> <pre><code>&gt;&gt;&gt; import argparse\n&gt;&gt;&gt; from argparse import ArgumentParser\n&gt;&gt;&gt; from typing import Sequence\n&gt;&gt;&gt; from corgy import CorgyHelpFormatter\n&gt;&gt;&gt; from corgy.types import InitArgs\n\n&gt;&gt;&gt; class Foo:\n...     def __init__(\n...         self,\n...         a: int,\n...         b: Sequence[str],\n...         c: float = 0.0,\n...     ):\n...         ...\n\n&gt;&gt;&gt; FooInitArgs = InitArgs[Foo]\n&gt;&gt;&gt; parser = ArgumentParser(\n...     formatter_class=CorgyHelpFormatter,\n...     add_help=False,\n...     usage=argparse.SUPPRESS,\n... )\n&gt;&gt;&gt; FooInitArgs.add_args_to_parser(parser)\n&gt;&gt;&gt; parser.print_help()\noptions:\n  --a int        (required)\n  --b [str ...]  (required)\n  --c float      (default: 0.0)\n\n&gt;&gt;&gt; args = parser.parse_args([\"--a\", \"1\", \"--b\", \"one\", \"two\"])\n&gt;&gt;&gt; foo = Foo(args.a, args.b, args.c)\n</code></pre> <p>This is a generic class, and on using the <code>InitArgs[Cls]</code> syntax, a concrete <code>Corgy</code> class is created, which has attributes corresponding to the arguments of <code>Cls.__init__</code>, with types inferred from annotations. The returned class can be used as any other <code>Corgy</code> class, including as a type annotation within another <code>Corgy</code> class.</p> <p>All arguments of the <code>__init__</code> method must be annotated, following the same rules as for other <code>Corgy</code> classes. Positional only arguments are not supported, since they are not associated with an argument name. <code>TypeError</code> is raised if either of these conditions is not met.</p>"},{"location":"usage/corgy.types.html#corgy.types.InputTextFile","title":"corgy.types.InputTextFile","text":"<p>         Bases: <code>TextIOWrapper</code></p> <p><code>TextIOWrapper</code> sub-class representing an input file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>StrPath</code> <p>Path to a file.</p> required <p>The file must exist, and will be opened in text mode (<code>r</code>). <code>ValueError</code> is raised if this fails. An <code>atexit</code> handler will be registered to close the file on program termination.</p>"},{"location":"usage/corgy.types.html#corgy.types._inputfile.InputTextFile.stdin_wrapper","title":"stdin_wrapper  <code>classmethod</code>","text":"<pre><code>stdin_wrapper()\n</code></pre> <p><code>sys.__stdin__</code> as <code>InputTextFile</code>.</p>"},{"location":"usage/corgy.types.html#corgy.types.InputBinFile","title":"corgy.types.InputBinFile","text":"<p>         Bases: <code>BufferedReader</code></p> <p>Type for an input binary file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>StrPath</code> <p>Path to a file.</p> required <p>This class is a thin wrapper around <code>BufferedReader</code> that accepts a path, instead of a file stream. The file must exist, and will be opened in binary mode. <code>ValueError</code> is raised if this fails. An <code>atexit</code> handler will be registered to close the file on program termination.</p>"},{"location":"usage/corgy.types.html#corgy.types._inputfile.InputBinFile.stdin_wrapper","title":"stdin_wrapper  <code>classmethod</code>","text":"<pre><code>stdin_wrapper()\n</code></pre> <p><code>sys.__stdin__</code> as <code>InputBinFile</code>.</p>"},{"location":"usage/corgy.types.html#corgy.types.OutputTextFile","title":"corgy.types.OutputTextFile","text":"<p>         Bases: <code>TextIOWrapper</code></p> <p><code>TextIOWrapper</code> sub-class representing an output file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>StrPath</code> <p>Path to a file.</p> required <p>The file will be created if it does not exist (including any parent directories), and opened in text mode (<code>w</code>). Existing files will be truncated. <code>ValueError</code> is raised if any of the operations fail. An <code>atexit</code> handler will be registered to close the file on program termination.</p>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.OutputTextFile.init","title":"init","text":"<pre><code>init()\n</code></pre> <p>No-op for compatibility with <code>LazyOutputTextFile</code>.</p>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.OutputTextFile.stderr_wrapper","title":"stderr_wrapper  <code>classmethod</code>","text":"<pre><code>stderr_wrapper()\n</code></pre> <p><code>sys.__stderr__</code> as <code>OutputTextFile</code>.</p>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.OutputTextFile.stdout_wrapper","title":"stdout_wrapper  <code>classmethod</code>","text":"<pre><code>stdout_wrapper()\n</code></pre> <p><code>sys.__stdout__</code> as <code>OutputTextFile</code>.</p>"},{"location":"usage/corgy.types.html#corgy.types.LazyOutputTextFile","title":"corgy.types.LazyOutputTextFile","text":"<p>         Bases: <code>OutputTextFile</code></p> <p><code>OutputTextFile</code> sub-class that does not auto-initialize.</p> <p>Useful for \"default\" files, which only need to be created if an alternative is not provided. <code>init</code> must be called on instances before they can be used.</p>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.LazyOutputTextFile.init","title":"init","text":"<pre><code>init()\n</code></pre> <p>Initialize the file.</p>"},{"location":"usage/corgy.types.html#corgy.types.OutputBinFile","title":"corgy.types.OutputBinFile","text":"<p>         Bases: <code>BufferedWriter</code></p> <p>Type for an output binary file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>StrPath</code> <p>Path to a file.</p> required <p>This class is a thin wrapper around <code>BufferedWriter</code> that accepts a path, instead of a file stream. The file will be created if it does not exist (including any parent directories), and opened in binary mode. Existing files will be truncated. <code>ValueError</code> is raised if any of the operations fail. An <code>atexit</code> handler will be registered to close the file on program termination.</p>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.OutputBinFile.init","title":"init","text":"<pre><code>init()\n</code></pre> <p>No-op for compatibility with <code>LazyOutputBinFile</code>.</p>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.OutputBinFile.stderr_wrapper","title":"stderr_wrapper  <code>classmethod</code>","text":"<pre><code>stderr_wrapper()\n</code></pre> <p><code>sys.__stderr__</code> as <code>OutputBinFile</code>.</p>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.OutputBinFile.stdout_wrapper","title":"stdout_wrapper  <code>classmethod</code>","text":"<pre><code>stdout_wrapper()\n</code></pre> <p><code>sys.__stdout__</code> as <code>OutputBinFile</code>.</p>"},{"location":"usage/corgy.types.html#corgy.types.LazyOutputBinFile","title":"corgy.types.LazyOutputBinFile","text":"<p>         Bases: <code>OutputBinFile</code></p> <p><code>OutputBinFile</code> sub-class that does not auto-initialize.</p> <p>Useful for \"default\" files, which only need to be created if an alternative is not provided. <code>init</code> must be called on instances before they can be used.</p>"},{"location":"usage/corgy.types.html#corgy.types._outputfile.LazyOutputBinFile.init","title":"init","text":"<pre><code>init()\n</code></pre> <p>Initialize the file.</p>"}]}